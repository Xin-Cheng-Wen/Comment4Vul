{"idx": 24595, "func": "static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block)\n{\n    int i;\n    int dc = block[0];\n    const uint8_t *cm;\n    dc = (3 * dc +  1) >> 1;\n    dc = (3 * dc + 16) >> 5;\n    cm = ff_cropTbl + MAX_NEG_CROP + dc;\n    for(i = 0; i < 8; i++){\n        dest[0] = cm[dest[0]];\n        dest[1] = cm[dest[1]];\n        dest[2] = cm[dest[2]];\n        dest[3] = cm[dest[3]];\n        dest[4] = cm[dest[4]];\n        dest[5] = cm[dest[5]];\n        dest[6] = cm[dest[6]];\n        dest[7] = cm[dest[7]];\n        dest += linesize;\n    }\n}"}
{"idx": 24597, "func": "static void compute_rematrixing_strategy(AC3EncodeContext *s)\n{\n    int nb_coefs;\n    int blk, bnd, i;\n    AC3Block *block, *block0;\n    s->num_rematrixing_bands = 4;\n    if (s->rematrixing & AC3_REMATRIXING_IS_STATIC)\n        return;\n    nb_coefs = FFMIN(s->nb_coefs[0], s->nb_coefs[1]);\n    for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) {\n        block = &s->blocks[blk];\n        block->new_rematrixing_strategy = !blk;\n        for (bnd = 0; bnd < s->num_rematrixing_bands; bnd++) {\n            int start = ff_ac3_rematrix_band_tab[bnd];\n            int end   = FFMIN(nb_coefs, ff_ac3_rematrix_band_tab[bnd+1]);\n            CoefSumType sum[4] = {0,};\n            for (i = start; i < end; i++) {\n                CoefType lt = block->mdct_coef[0][i];\n                CoefType rt = block->mdct_coef[1][i];\n                CoefType md = lt + rt;\n                CoefType sd = lt - rt;\n                sum[0] += lt * lt;\n                sum[1] += rt * rt;\n                sum[2] += md * md;\n                sum[3] += sd * sd;\n            }\n            if (FFMIN(sum[2], sum[3]) < FFMIN(sum[0], sum[1]))\n                block->rematrixing_flags[bnd] = 1;\n            else\n                block->rematrixing_flags[bnd] = 0;\n            if (blk &&\n                block->rematrixing_flags[bnd] != block0->rematrixing_flags[bnd]) {\n                block->new_rematrixing_strategy = 1;\n            }\n        }\n        block0 = block;\n    }\n}"}
{"idx": 24606, "func": "static int cbs_h265_read_nal_unit(CodedBitstreamContext *ctx,\n                                  CodedBitstreamUnit *unit)\n{\n    BitstreamContext bc;\n    int err;\n    err = bitstream_init(&bc, unit->data, 8 * unit->data_size);\n    if (err < 0)\n        return err;\n    switch (unit->type) {\n    case HEVC_NAL_VPS:\n        {\n            H265RawVPS *vps;\n            vps = av_mallocz(sizeof(*vps));\n            if (!vps)\n                return AVERROR(ENOMEM);\n            err = cbs_h265_read_vps(ctx, &bc, vps);\n            if (err >= 0)\n                err = cbs_h265_replace_vps(ctx, vps);\n            if (err < 0) {\n                av_free(vps);\n                return err;\n            }\n            unit->content = vps;\n        }\n        break;\n    case HEVC_NAL_SPS:\n        {\n            H265RawSPS *sps;\n            sps = av_mallocz(sizeof(*sps));\n            if (!sps)\n                return AVERROR(ENOMEM);\n            err = cbs_h265_read_sps(ctx, &bc, sps);\n            if (err >= 0)\n                err = cbs_h265_replace_sps(ctx, sps);\n            if (err < 0) {\n                av_free(sps);\n                return err;\n            }\n            unit->content = sps;\n        }\n        break;\n    case HEVC_NAL_PPS:\n        {\n            H265RawPPS *pps;\n            pps = av_mallocz(sizeof(*pps));\n            if (!pps)\n                return AVERROR(ENOMEM);\n            err = cbs_h265_read_pps(ctx, &bc, pps);\n            if (err >= 0)\n                err = cbs_h265_replace_pps(ctx, pps);\n            if (err < 0) {\n                av_free(pps);\n                return err;\n            }\n            unit->content = pps;\n        }\n        break;\n    case HEVC_NAL_TRAIL_N:\n    case HEVC_NAL_TRAIL_R:\n    case HEVC_NAL_TSA_N:\n    case HEVC_NAL_TSA_R:\n    case HEVC_NAL_STSA_N:\n    case HEVC_NAL_STSA_R:\n    case HEVC_NAL_RADL_N:\n    case HEVC_NAL_RADL_R:\n    case HEVC_NAL_RASL_N:\n    case HEVC_NAL_RASL_R:\n    case HEVC_NAL_BLA_W_LP:\n    case HEVC_NAL_BLA_W_RADL:\n    case HEVC_NAL_BLA_N_LP:\n    case HEVC_NAL_IDR_W_RADL:\n    case HEVC_NAL_IDR_N_LP:\n    case HEVC_NAL_CRA_NUT:\n        {\n            H265RawSlice *slice;\n            int pos, len;\n            slice = av_mallocz(sizeof(*slice));\n            if (!slice)\n                return AVERROR(ENOMEM);\n            err = cbs_h265_read_slice_segment_header(ctx, &bc, &slice->header);\n            if (err < 0) {\n                av_free(slice);\n                return err;\n            }\n            pos = bitstream_tell(&bc);\n            len = unit->data_size;\n            if (!unit->data[len - 1]) {\n                int z;\n                for (z = 0; z < len && !unit->data[len - z - 1]; z++);\n                av_log(ctx->log_ctx, AV_LOG_DEBUG, \"Deleted %d trailing zeroes \"\n                       \"from slice data.\\n\", z);\n                len -= z;\n            }\n            slice->data_size = len - pos / 8;\n            slice->data = av_malloc(slice->data_size);\n            if (!slice->data) {\n                av_free(slice);\n                return AVERROR(ENOMEM);\n            }\n            memcpy(slice->data,\n                   unit->data + pos / 8, slice->data_size);\n            slice->data_bit_start = pos % 8;\n            unit->content = slice;\n        }\n        break;\n    case HEVC_NAL_AUD:\n        {\n            H265RawAUD *aud;\n            aud = av_mallocz(sizeof(*aud));\n            if (!aud)\n                return AVERROR(ENOMEM);\n            err = cbs_h265_read_aud(ctx, &bc, aud);\n            if (err < 0) {\n                av_free(aud);\n                return err;\n            }\n            unit->content = aud;\n        }\n        break;\n    default:\n        return AVERROR(ENOSYS);\n    }\n    return 0;\n}"}
{"idx": 24626, "func": "static int crypto_open(URLContext *h, const char *uri, int flags)\n{\n    const char *nested_url;\n    int ret;\n    CryptoContext *c = h->priv_data;\n    if (!av_strstart(uri, \"crypto+\", &nested_url) &&\n        !av_strstart(uri, \"crypto:\", &nested_url)) {\n        av_log(h, AV_LOG_ERROR, \"Unsupported url %s\\n\", uri);\n        ret = AVERROR(EINVAL);\n        goto err;\n    }\n    if (c->keylen < BLOCKSIZE || c->ivlen < BLOCKSIZE) {\n        av_log(h, AV_LOG_ERROR, \"Key or IV not set\\n\");\n        ret = AVERROR(EINVAL);\n        goto err;\n    }\n    if (flags & AVIO_FLAG_WRITE) {\n        av_log(h, AV_LOG_ERROR, \"Only decryption is supported currently\\n\");\n        ret = AVERROR(ENOSYS);\n        goto err;\n    }\n    if ((ret = ffurl_open(&c->hd, nested_url, AVIO_FLAG_READ)) < 0) {\n        av_log(h, AV_LOG_ERROR, \"Unable to open input\\n\");\n        goto err;\n    }\n    c->aes = av_mallocz(av_aes_size);\n    if (!c->aes) {\n        ret = AVERROR(ENOMEM);\n        goto err;\n    }\n    av_aes_init(c->aes, c->key, 128, 1);\n    h->is_streamed = 1;\n    return 0;\nerr:\n    av_free(c->key);\n    av_free(c->iv);\n    return ret;\n}"}
{"idx": 24627, "func": "int ff_alloc_entries(AVCodecContext *avctx, int count)\n{\n    int i;\n    if (avctx->active_thread_type & FF_THREAD_SLICE)  {\n        SliceThreadContext *p = avctx->internal->thread_ctx;\n        p->thread_count  = avctx->thread_count;\n        p->entries       = av_mallocz_array(count, sizeof(int));\n        if (!p->entries) {\n            return AVERROR(ENOMEM);\n        }\n        p->entries_count  = count;\n        p->progress_mutex = av_malloc_array(p->thread_count, sizeof(pthread_mutex_t));\n        p->progress_cond  = av_malloc_array(p->thread_count, sizeof(pthread_cond_t));\n        for (i = 0; i < p->thread_count; i++) {\n            pthread_mutex_init(&p->progress_mutex[i], NULL);\n            pthread_cond_init(&p->progress_cond[i], NULL);\n        }\n    }\n    return 0;\n}"}
{"idx": 24632, "func": "DeviceState *qdev_device_add(QemuOpts *opts)\n{\n    ObjectClass *oc;\n    DeviceClass *dc;\n    const char *driver, *path, *id;\n    DeviceState *dev;\n    BusState *bus = NULL;\n    Error *err = NULL;\n    driver = qemu_opt_get(opts, \"driver\");\n    if (!driver) {\n        qerror_report(QERR_MISSING_PARAMETER, \"driver\");\n        return NULL;\n    }\n    oc = object_class_by_name(driver);\n    if (!oc) {\n        const char *typename = find_typename_by_alias(driver);\n        if (typename) {\n            driver = typename;\n            oc = object_class_by_name(driver);\n        }\n    }\n    if (!object_class_dynamic_cast(oc, TYPE_DEVICE)) {\n        qerror_report(ERROR_CLASS_GENERIC_ERROR,\n                      \"'%s' is not a valid device model name\", driver);\n        return NULL;\n    }\n    if (object_class_is_abstract(oc)) {\n        qerror_report(QERR_INVALID_PARAMETER_VALUE, \"driver\",\n                      \"non-abstract device type\");\n        return NULL;\n    }\n    dc = DEVICE_CLASS(oc);\n    if (dc->cannot_instantiate_with_device_add_yet) {\n        qerror_report(QERR_INVALID_PARAMETER_VALUE, \"driver\",\n                      \"pluggable device type\");\n        return NULL;\n    }\n    path = qemu_opt_get(opts, \"bus\");\n    if (path != NULL) {\n        bus = qbus_find(path);\n        if (!bus) {\n            return NULL;\n        }\n        if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) {\n            qerror_report(QERR_BAD_BUS_FOR_DEVICE,\n                          driver, object_get_typename(OBJECT(bus)));\n            return NULL;\n        }\n    } else if (dc->bus_type != NULL) {\n        bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);\n        if (!bus) {\n            qerror_report(QERR_NO_BUS_FOR_DEVICE,\n                          dc->bus_type, driver);\n            return NULL;\n        }\n    }\n    if (qdev_hotplug && bus && !bus->allow_hotplug) {\n        qerror_report(QERR_BUS_NO_HOTPLUG, bus->name);\n        return NULL;\n    }\n    dev = DEVICE(object_new(driver));\n    if (bus) {\n        qdev_set_parent_bus(dev, bus);\n    }\n    id = qemu_opts_id(opts);\n    if (id) {\n        dev->id = id;\n    }\n    if (qemu_opt_foreach(opts, set_property, dev, 1) != 0) {\n        object_unparent(OBJECT(dev));\n        object_unref(OBJECT(dev));\n        return NULL;\n    }\n    if (dev->id) {\n        object_property_add_child(qdev_get_peripheral(), dev->id,\n                                  OBJECT(dev), NULL);\n    } else {\n        static int anon_count;\n        gchar *name = g_strdup_printf(\"device[%d]\", anon_count++);\n        object_property_add_child(qdev_get_peripheral_anon(), name,\n                                  OBJECT(dev), NULL);\n        g_free(name);\n    }\n    dev->opts = opts;\n    object_property_set_bool(OBJECT(dev), true, \"realized\", &err);\n    if (err != NULL) {\n        qerror_report_err(err);\n        error_free(err);\n        dev->opts = NULL;\n        object_unparent(OBJECT(dev));\n        object_unref(OBJECT(dev));\n        qerror_report(QERR_DEVICE_INIT_FAILED, driver);\n        return NULL;\n    }\n    return dev;\n}"}
{"idx": 24634, "func": "static void pl061_register_devices(void)\n{\n    sysbus_register_dev(\"pl061\", sizeof(pl061_state),\n                        pl061_init_arm);\n    sysbus_register_dev(\"pl061_luminary\", sizeof(pl061_state),\n                        pl061_init_luminary);\n}"}
{"idx": 24641, "func": "CommandInfoList *qmp_query_commands(Error **errp)\n{\n    CommandInfoList *list = NULL;\n    qmp_for_each_command(&qmp_commands, query_commands_cb, &list);\n    return list;\n}"}
{"idx": 24642, "func": "static int decode_blocks(ALSDecContext *ctx, unsigned int ra_frame,\n                         unsigned int c, const unsigned int *div_blocks,\n                         unsigned int *js_blocks)\n{\n    ALSSpecificConfig *sconf = &ctx->sconf;\n    unsigned int offset = 0;\n    unsigned int b;\n    ALSBlockData bd[2] = { { 0 } };\n    bd[0].ra_block         = ra_frame;\n    bd[0].const_block      = ctx->const_block;\n    bd[0].shift_lsbs       = ctx->shift_lsbs;\n    bd[0].opt_order        = ctx->opt_order;\n    bd[0].store_prev_samples = ctx->store_prev_samples;\n    bd[0].use_ltp          = ctx->use_ltp;\n    bd[0].ltp_lag          = ctx->ltp_lag;\n    bd[0].ltp_gain         = ctx->ltp_gain[0];\n    bd[0].quant_cof        = ctx->quant_cof[0];\n    bd[0].lpc_cof          = ctx->lpc_cof[0];\n    bd[0].prev_raw_samples = ctx->prev_raw_samples;\n    bd[0].js_blocks        = *js_blocks;\n    bd[1].ra_block         = ra_frame;\n    bd[1].const_block      = ctx->const_block;\n    bd[1].shift_lsbs       = ctx->shift_lsbs;\n    bd[1].opt_order        = ctx->opt_order;\n    bd[1].store_prev_samples = ctx->store_prev_samples;\n    bd[1].use_ltp          = ctx->use_ltp;\n    bd[1].ltp_lag          = ctx->ltp_lag;\n    bd[1].ltp_gain         = ctx->ltp_gain[0];\n    bd[1].quant_cof        = ctx->quant_cof[0];\n    bd[1].lpc_cof          = ctx->lpc_cof[0];\n    bd[1].prev_raw_samples = ctx->prev_raw_samples;\n    bd[1].js_blocks        = *(js_blocks + 1);\n    for (b = 0; b < ctx->num_blocks; b++) {\n        unsigned int s;\n        bd[0].block_length = div_blocks[b];\n        bd[1].block_length = div_blocks[b];\n        bd[0].raw_samples  = ctx->raw_samples[c    ] + offset;\n        bd[1].raw_samples  = ctx->raw_samples[c + 1] + offset;\n        bd[0].raw_other    = bd[1].raw_samples;\n        bd[1].raw_other    = bd[0].raw_samples;\n        if(read_decode_block(ctx, &bd[0]) || read_decode_block(ctx, &bd[1])) {\n            zero_remaining(b, ctx->num_blocks, div_blocks, bd[0].raw_samples);\n            zero_remaining(b, ctx->num_blocks, div_blocks, bd[1].raw_samples);\n            return -1;\n        }\n        if (bd[0].js_blocks) {\n            if (bd[1].js_blocks)\n                av_log(ctx->avctx, AV_LOG_WARNING, \"Invalid channel pair!\\n\");\n            for (s = 0; s < div_blocks[b]; s++)\n                bd[0].raw_samples[s] = bd[1].raw_samples[s] - bd[0].raw_samples[s];\n        } else if (bd[1].js_blocks) {\n            for (s = 0; s < div_blocks[b]; s++)\n                bd[1].raw_samples[s] = bd[1].raw_samples[s] + bd[0].raw_samples[s];\n        }\n        offset  += div_blocks[b];\n        bd[0].ra_block = 0;\n        bd[1].ra_block = 0;\n    }\n    memmove(ctx->raw_samples[c] - sconf->max_order,\n            ctx->raw_samples[c] - sconf->max_order + sconf->frame_length,\n            sizeof(*ctx->raw_samples[c]) * sconf->max_order);\n    return 0;\n}"}
{"idx": 24643, "func": "static int write_f(int argc, char **argv)\n{\n    struct timeval t1, t2;\n    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;\n    int c, cnt;\n    char *buf;\n    int64_t offset;\n    int count;\n    int total = 0;\n    int pattern = 0xcd;\n    while ((c = getopt(argc, argv, \"bCpP:q\")) != EOF) {\n        switch (c) {\n        case 'b':\n            bflag = 1;\n            break;\n        case 'C':\n            Cflag = 1;\n            break;\n        case 'p':\n            pflag = 1;\n            break;\n        case 'P':\n            pattern = parse_pattern(optarg);\n            if (pattern < 0) {\n                return 0;\n            }\n            break;\n        case 'q':\n            qflag = 1;\n            break;\n        default:\n            return command_usage(&write_cmd);\n        }\n    }\n    if (optind != argc - 2) {\n        return command_usage(&write_cmd);\n    }\n    if (bflag && pflag) {\n        printf(\"-b and -p cannot be specified at the same time\\n\");\n        return 0;\n    }\n    offset = cvtnum(argv[optind]);\n    if (offset < 0) {\n        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n        return 0;\n    }\n    optind++;\n    count = cvtnum(argv[optind]);\n    if (count < 0) {\n        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n        return 0;\n    }\n    if (!pflag) {\n        if (offset & 0x1ff) {\n            printf(\"offset %\" PRId64 \" is not sector aligned\\n\",\n                   offset);\n            return 0;\n        }\n        if (count & 0x1ff) {\n            printf(\"count %d is not sector aligned\\n\",\n                   count);\n            return 0;\n        }\n    }\n    buf = qemu_io_alloc(count, pattern);\n    gettimeofday(&t1, NULL);\n    if (pflag) {\n        cnt = do_pwrite(buf, offset, count, &total);\n    } else if (bflag) {\n        cnt = do_save_vmstate(buf, offset, count, &total);\n    } else {\n        cnt = do_write(buf, offset, count, &total);\n    }\n    gettimeofday(&t2, NULL);\n    if (cnt < 0) {\n        printf(\"write failed: %s\\n\", strerror(-cnt));\n        goto out;\n    }\n    if (qflag) {\n        goto out;\n    }\n    t2 = tsub(t2, t1);\n    print_report(\"wrote\", &t2, offset, count, total, cnt, Cflag);\nout:\n    qemu_io_free(buf);\n    return 0;\n}"}
{"idx": 24645, "func": "static void build_feed_streams(void)\n{\n    FFStream *stream, *feed;\n    int i;\n    for(stream = first_stream; stream != NULL; stream = stream->next) {\n        feed = stream->feed;\n        if (feed) {\n            if (!stream->is_feed) {\n                for(i=0;i<stream->nb_streams;i++)\n                    stream->feed_streams[i] = add_av_stream(feed, stream->streams[i]);\n            }\n        }\n    }\n    for(stream = first_stream; stream != NULL; stream = stream->next) {\n        feed = stream->feed;\n        if (feed) {\n            if (stream->is_feed) {\n                for(i=0;i<stream->nb_streams;i++)\n                    stream->feed_streams[i] = i;\n            }\n        }\n    }\n    for(feed = first_feed; feed != NULL; feed = feed->next_feed) {\n        int fd;\n        if (url_exist(feed->feed_filename)) {\n            AVFormatContext *s;\n            int matches = 0;\n            if (av_open_input_file(&s, feed->feed_filename, NULL, FFM_PACKET_SIZE, NULL) >= 0) {\n                if (s->nb_streams == feed->nb_streams) {\n                    matches = 1;\n                    for(i=0;i<s->nb_streams;i++) {\n                        AVStream *sf, *ss;\n                        sf = feed->streams[i];\n                        ss = s->streams[i];\n                        if (sf->index != ss->index ||\n                            sf->id != ss->id) {\n                            http_log(\"Index & Id do not match for stream %d (%s)\\n\",\n                                   i, feed->feed_filename);\n                            matches = 0;\n                        } else {\n                            AVCodecContext *ccf, *ccs;\n                            ccf = sf->codec;\n                            ccs = ss->codec;\n#define CHECK_CODEC(x)  (ccf->x != ccs->x)\n                            if (CHECK_CODEC(codec_id) || CHECK_CODEC(codec_type)) {\n                                http_log(\"Codecs do not match for stream %d\\n\", i);\n                                matches = 0;\n                            } else if (CHECK_CODEC(bit_rate) || CHECK_CODEC(flags)) {\n                                http_log(\"Codec bitrates do not match for stream %d\\n\", i);\n                                matches = 0;\n                            } else if (ccf->codec_type == AVMEDIA_TYPE_VIDEO) {\n                                if (CHECK_CODEC(time_base.den) ||\n                                    CHECK_CODEC(time_base.num) ||\n                                    CHECK_CODEC(width) ||\n                                    CHECK_CODEC(height)) {\n                                    http_log(\"Codec width, height and framerate do not match for stream %d\\n\", i);\n                                    matches = 0;\n                                }\n                            } else if (ccf->codec_type == AVMEDIA_TYPE_AUDIO) {\n                                if (CHECK_CODEC(sample_rate) ||\n                                    CHECK_CODEC(channels) ||\n                                    CHECK_CODEC(frame_size)) {\n                                    http_log(\"Codec sample_rate, channels, frame_size do not match for stream %d\\n\", i);\n                                    matches = 0;\n                                }\n                            } else {\n                                http_log(\"Unknown codec type\\n\");\n                                matches = 0;\n                            }\n                        }\n                        if (!matches)\n                            break;\n                    }\n                } else\n                    http_log(\"Deleting feed file '%s' as stream counts differ (%d != %d)\\n\",\n                        feed->feed_filename, s->nb_streams, feed->nb_streams);\n                av_close_input_file(s);\n            } else\n                http_log(\"Deleting feed file '%s' as it appears to be corrupt\\n\",\n                        feed->feed_filename);\n            if (!matches) {\n                if (feed->readonly) {\n                    http_log(\"Unable to delete feed file '%s' as it is marked readonly\\n\",\n                        feed->feed_filename);\n                    exit(1);\n                }\n                unlink(feed->feed_filename);\n            }\n        }\n        if (!url_exist(feed->feed_filename)) {\n            AVFormatContext s1 = {0}, *s = &s1;\n            if (feed->readonly) {\n                http_log(\"Unable to create feed file '%s' as it is marked readonly\\n\",\n                    feed->feed_filename);\n                exit(1);\n            }\n            if (avio_open(&s->pb, feed->feed_filename, AVIO_FLAG_WRITE) < 0) {\n                http_log(\"Could not open output feed file '%s'\\n\",\n                         feed->feed_filename);\n                exit(1);\n            }\n            s->oformat = feed->fmt;\n            s->nb_streams = feed->nb_streams;\n            for(i=0;i<s->nb_streams;i++) {\n                AVStream *st;\n                st = feed->streams[i];\n                s->streams[i] = st;\n            }\n            av_set_parameters(s, NULL);\n            if (av_write_header(s) < 0) {\n                http_log(\"Container doesn't supports the required parameters\\n\");\n                exit(1);\n            }\n            av_freep(&s->priv_data);\n            avio_close(s->pb);\n        }\n        fd = open(feed->feed_filename, O_RDONLY);\n        if (fd < 0) {\n            http_log(\"Could not open output feed file '%s'\\n\",\n                    feed->feed_filename);\n            exit(1);\n        }\n        feed->feed_write_index = FFMAX(ffm_read_write_index(fd), FFM_PACKET_SIZE);\n        feed->feed_size = lseek(fd, 0, SEEK_END);\n        if (feed->feed_max_size && feed->feed_max_size < feed->feed_size)\n            feed->feed_max_size = feed->feed_size;\n        close(fd);\n    }\n}"}
{"idx": 24653, "func": "void tcp_start_incoming_migration(const char *host_port, Error **errp)\n{\n    int s;\n    s = inet_listen(host_port, NULL, 256, SOCK_STREAM, 0, errp);\n    if (s < 0) {\n        return;\n    }\n    qemu_set_fd_handler2(s, NULL, tcp_accept_incoming_migration, NULL,\n                         (void *)(intptr_t)s);\n}"}
{"idx": 24657, "func": "static coroutine_fn int sd_co_writev(BlockDriverState *bs, int64_t sector_num,\n                        int nb_sectors, QEMUIOVector *qiov)\n{\n    SheepdogAIOCB *acb;\n    int ret;\n    if (bs->growable && sector_num + nb_sectors > bs->total_sectors) {\n        ret = sd_truncate(bs, (sector_num + nb_sectors) * BDRV_SECTOR_SIZE);\n        if (ret < 0) {\n            return ret;\n        }\n        bs->total_sectors = sector_num + nb_sectors;\n    }\n    acb = sd_aio_setup(bs, qiov, sector_num, nb_sectors);\n    acb->aio_done_func = sd_write_done;\n    acb->aiocb_type = AIOCB_WRITE_UDATA;\n    ret = sd_co_rw_vector(acb);\n    if (ret <= 0) {\n        qemu_aio_release(acb);\n        return ret;\n    }\n    qemu_coroutine_yield();\n    return acb->ret;\n}"}
{"idx": 24669, "func": "MigrationState *exec_start_outgoing_migration(const char *command,\n                                             int64_t bandwidth_limit,\n                                             int async)\n{\n    FdMigrationState *s;\n    FILE *f;\n    s = qemu_mallocz(sizeof(*s));\n    if (s == NULL) {\n        dprintf(\"Unable to allocate FdMigrationState\\n\");\n        goto err;\n    }\n    f = popen(command, \"w\");\n    if (f == NULL) {\n        dprintf(\"Unable to popen exec target\\n\");\n        goto err_after_alloc;\n    }\n    s->fd = fileno(f);\n    if (s->fd == -1) {\n        dprintf(\"Unable to retrieve file descriptor for popen'd handle\\n\");\n        goto err_after_open;\n    }\n    if (fcntl(s->fd, F_SETFD, O_NONBLOCK) == -1) {\n        dprintf(\"Unable to set nonblocking mode on file descriptor\\n\");\n        goto err_after_open;\n    }\n    s->opaque = qemu_popen(f, \"w\");\n    s->get_error = file_errno;\n    s->write = file_write;\n    s->mig_state.cancel = migrate_fd_cancel;\n    s->mig_state.get_status = migrate_fd_get_status;\n    s->mig_state.release = migrate_fd_release;\n    s->state = MIG_STATE_ACTIVE;\n    s->detach = !async;\n    s->bandwidth_limit = bandwidth_limit;\n    if (s->detach == 1) {\n        dprintf(\"detaching from monitor\\n\");\n        monitor_suspend();\n        s->detach = 2;\n    }\n    migrate_fd_connect(s);\n    return &s->mig_state;\nerr_after_open:\n    pclose(f);\nerr_after_alloc:\n    qemu_free(s);\nerr:\n    return NULL;\n}"}
{"idx": 24673, "func": "ff_rm_parse_packet (AVFormatContext *s, AVIOContext *pb,\n                    AVStream *st, RMStream *ast, int len, AVPacket *pkt,\n                    int *seq, int flags, int64_t timestamp)\n{\n    RMDemuxContext *rm = s->priv_data;\n    int ret;\n    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n        rm->current_stream= st->id;\n        ret = rm_assemble_video_frame(s, pb, rm, ast, pkt, len, seq, &timestamp);\n        if(ret)\n            return ret < 0 ? ret : -1;  \n    } else if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {\n        if ((ast->deint_id == DEINT_ID_GENR) ||\n            (ast->deint_id == DEINT_ID_INT4) ||\n            (ast->deint_id == DEINT_ID_SIPR)) {\n            int x;\n            int sps = ast->sub_packet_size;\n            int cfs = ast->coded_framesize;\n            int h = ast->sub_packet_h;\n            int y = ast->sub_packet_cnt;\n            int w = ast->audio_framesize;\n            if (flags & 2)\n                y = ast->sub_packet_cnt = 0;\n            if (!y)\n                ast->audiotimestamp = timestamp;\n            switch (ast->deint_id) {\n                case DEINT_ID_INT4:\n                    for (x = 0; x < h/2; x++)\n                        avio_read(pb, ast->pkt.data+x*2*w+y*cfs, cfs);\n                    break;\n                case DEINT_ID_GENR:\n                    for (x = 0; x < w/sps; x++)\n                        avio_read(pb, ast->pkt.data+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), sps);\n                    break;\n                case DEINT_ID_SIPR:\n                    avio_read(pb, ast->pkt.data + y * w, w);\n                    break;\n            }\n            if (++(ast->sub_packet_cnt) < h)\n                return -1;\n            if (ast->deint_id == DEINT_ID_SIPR)\n                ff_rm_reorder_sipr_data(ast->pkt.data, h, w);\n             ast->sub_packet_cnt = 0;\n             rm->audio_stream_num = st->index;\n             rm->audio_pkt_cnt = h * w / st->codec->block_align;\n        } else if ((ast->deint_id == DEINT_ID_VBRF) ||\n                   (ast->deint_id == DEINT_ID_VBRS)) {\n            int x;\n            rm->audio_stream_num = st->index;\n            ast->sub_packet_cnt = (avio_rb16(pb) & 0xf0) >> 4;\n            if (ast->sub_packet_cnt) {\n                for (x = 0; x < ast->sub_packet_cnt; x++)\n                    ast->sub_packet_lengths[x] = avio_rb16(pb);\n                rm->audio_pkt_cnt = ast->sub_packet_cnt;\n                ast->audiotimestamp = timestamp;\n            } else\n                return -1;\n        } else {\n            av_get_packet(pb, pkt, len);\n            rm_ac3_swap_bytes(st, pkt);\n        }\n    } else\n        av_get_packet(pb, pkt, len);\n    pkt->stream_index = st->index;\n#if 0\n    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n        if(st->codec->codec_id == AV_CODEC_ID_RV20){\n            int seq= 128*(pkt->data[2]&0x7F) + (pkt->data[3]>>1);\n            av_log(s, AV_LOG_DEBUG, \"%d %\"PRId64\" %d\\n\", *timestamp, *timestamp*512LL/25, seq);\n            seq |= (timestamp&~0x3FFF);\n            if(seq - timestamp >  0x2000) seq -= 0x4000;\n            if(seq - timestamp < -0x2000) seq += 0x4000;\n        }\n    }\n#endif\n    pkt->pts = timestamp;\n    if (flags & 2)\n        pkt->flags |= AV_PKT_FLAG_KEY;\n    return st->codec->codec_type == AVMEDIA_TYPE_AUDIO ? rm->audio_pkt_cnt : 0;\n}"}
{"idx": 24676, "func": "void cpu_tick_set_count(CPUTimer *timer, uint64_t count)\n{\n    uint64_t real_count = count & ~timer->disabled_mask;\n    uint64_t disabled_bit = count & timer->disabled_mask;\n    int64_t vm_clock_offset = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) -\n                    cpu_to_timer_ticks(real_count, timer->frequency);\n    TIMER_DPRINTF(\"%s set_count count=0x%016lx (%s) p=%p\\n\",\n                  timer->name, real_count,\n                  timer->disabled?\"disabled\":\"enabled\", timer);\n    timer->disabled = disabled_bit ? 1 : 0;\n    timer->clock_offset = vm_clock_offset;\n}"}
{"idx": 24689, "func": "PXA2xxState *pxa255_init(unsigned int sdram_size)\n{\n    PXA2xxState *s;\n    int iomemtype, i;\n    DriveInfo *dinfo;\n    s = (PXA2xxState *) qemu_mallocz(sizeof(PXA2xxState));\n    s->env = cpu_init(\"pxa255\");\n    if (!s->env) {\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n        exit(1);\n    }\n    s->reset = qemu_allocate_irqs(pxa2xx_reset, s, 1)[0];\n    cpu_register_physical_memory(PXA2XX_SDRAM_BASE, sdram_size,\n                    qemu_ram_alloc(NULL, \"pxa255.sdram\",\n                                   sdram_size) | IO_MEM_RAM);\n    cpu_register_physical_memory(PXA2XX_INTERNAL_BASE, PXA2XX_INTERNAL_SIZE,\n                    qemu_ram_alloc(NULL, \"pxa255.internal\",\n                                   PXA2XX_INTERNAL_SIZE) | IO_MEM_RAM);\n    s->pic = pxa2xx_pic_init(0x40d00000, s->env);\n    s->dma = pxa255_dma_init(0x40000000, s->pic[PXA2XX_PIC_DMA]);\n    pxa25x_timer_init(0x40a00000, &s->pic[PXA2XX_PIC_OST_0]);\n    s->gpio = pxa2xx_gpio_init(0x40e00000, s->env, s->pic, 85);\n    dinfo = drive_get(IF_SD, 0, 0);\n    if (!dinfo) {\n        fprintf(stderr, \"qemu: missing SecureDigital device\\n\");\n        exit(1);\n    }\n    s->mmc = pxa2xx_mmci_init(0x41100000, dinfo->bdrv,\n                              s->pic[PXA2XX_PIC_MMC], s->dma);\n    for (i = 0; pxa255_serial[i].io_base; i ++)\n        if (serial_hds[i]) {\n#ifdef TARGET_WORDS_BIGENDIAN\n            serial_mm_init(pxa255_serial[i].io_base, 2,\n                           s->pic[pxa255_serial[i].irqn], 14745600/16,\n                           serial_hds[i], 1, 1);\n#else\n            serial_mm_init(pxa255_serial[i].io_base, 2,\n                           s->pic[pxa255_serial[i].irqn], 14745600/16,\n                           serial_hds[i], 1, 0);\n#endif\n        } else {\n            break;\n        }\n    if (serial_hds[i])\n        s->fir = pxa2xx_fir_init(0x40800000, s->pic[PXA2XX_PIC_ICP],\n                        s->dma, serial_hds[i]);\n    s->lcd = pxa2xx_lcdc_init(0x44000000, s->pic[PXA2XX_PIC_LCD]);\n    s->cm_base = 0x41300000;\n    s->cm_regs[CCCR >> 2] = 0x02000210;\t \n    s->clkcfg = 0x00000009;\t\t \n    iomemtype = cpu_register_io_memory(pxa2xx_cm_readfn,\n                    pxa2xx_cm_writefn, s, DEVICE_NATIVE_ENDIAN);\n    cpu_register_physical_memory(s->cm_base, 0x1000, iomemtype);\n    register_savevm(NULL, \"pxa2xx_cm\", 0, 0, pxa2xx_cm_save, pxa2xx_cm_load, s);\n    cpu_arm_set_cp_io(s->env, 14, pxa2xx_cp14_read, pxa2xx_cp14_write, s);\n    s->mm_base = 0x48000000;\n    s->mm_regs[MDMRS >> 2] = 0x00020002;\n    s->mm_regs[MDREFR >> 2] = 0x03ca4000;\n    s->mm_regs[MECR >> 2] = 0x00000001;\t \n    iomemtype = cpu_register_io_memory(pxa2xx_mm_readfn,\n                    pxa2xx_mm_writefn, s, DEVICE_NATIVE_ENDIAN);\n    cpu_register_physical_memory(s->mm_base, 0x1000, iomemtype);\n    register_savevm(NULL, \"pxa2xx_mm\", 0, 0, pxa2xx_mm_save, pxa2xx_mm_load, s);\n    s->pm_base = 0x40f00000;\n    iomemtype = cpu_register_io_memory(pxa2xx_pm_readfn,\n                    pxa2xx_pm_writefn, s, DEVICE_NATIVE_ENDIAN);\n    cpu_register_physical_memory(s->pm_base, 0x100, iomemtype);\n    register_savevm(NULL, \"pxa2xx_pm\", 0, 0, pxa2xx_pm_save, pxa2xx_pm_load, s);\n    for (i = 0; pxa255_ssp[i].io_base; i ++);\n    s->ssp = (SSIBus **)qemu_mallocz(sizeof(SSIBus *) * i);\n    for (i = 0; pxa255_ssp[i].io_base; i ++) {\n        DeviceState *dev;\n        dev = sysbus_create_simple(\"pxa2xx-ssp\", pxa255_ssp[i].io_base,\n                                   s->pic[pxa255_ssp[i].irqn]);\n        s->ssp[i] = (SSIBus *)qdev_get_child_bus(dev, \"ssi\");\n    }\n    if (usb_enabled) {\n        sysbus_create_simple(\"sysbus-ohci\", 0x4c000000,\n                             s->pic[PXA2XX_PIC_USBH1]);\n    }\n    s->pcmcia[0] = pxa2xx_pcmcia_init(0x20000000);\n    s->pcmcia[1] = pxa2xx_pcmcia_init(0x30000000);\n    s->rtc_base = 0x40900000;\n    iomemtype = cpu_register_io_memory(pxa2xx_rtc_readfn,\n                    pxa2xx_rtc_writefn, s, DEVICE_NATIVE_ENDIAN);\n    cpu_register_physical_memory(s->rtc_base, 0x1000, iomemtype);\n    pxa2xx_rtc_init(s);\n    register_savevm(NULL, \"pxa2xx_rtc\", 0, 0, pxa2xx_rtc_save,\n                    pxa2xx_rtc_load, s);\n    s->i2c[0] = pxa2xx_i2c_init(0x40301600, s->pic[PXA2XX_PIC_I2C], 0xffff);\n    s->i2c[1] = pxa2xx_i2c_init(0x40f00100, s->pic[PXA2XX_PIC_PWRI2C], 0xff);\n    s->i2s = pxa2xx_i2s_init(0x40400000, s->pic[PXA2XX_PIC_I2S], s->dma);\n    qdev_connect_gpio_out(s->gpio, 1, s->reset);\n    return s;\n}"}
{"idx": 24694, "func": "static int alac_decode_frame(AVCodecContext *avctx,\n                             void *outbuffer, int *outputsize,\n                             const uint8_t *inbuffer, int input_buffer_size)\n{\n    ALACContext *alac = avctx->priv_data;\n    int channels;\n    unsigned int outputsamples;\n    int hassize;\n    int readsamplesize;\n    int wasted_bytes;\n    int isnotcompressed;\n    uint8_t interlacing_shift;\n    uint8_t interlacing_leftweight;\n    if (!inbuffer || !input_buffer_size)\n        return input_buffer_size;\n    if (!alac->context_initialized) {\n        if (alac->avctx->extradata_size != ALAC_EXTRADATA_SIZE) {\n            av_log(avctx, AV_LOG_ERROR, \"alac: expected %d extradata bytes\\n\",\n                ALAC_EXTRADATA_SIZE);\n            return input_buffer_size;\n        }\n        if (alac_set_info(alac)) {\n            av_log(avctx, AV_LOG_ERROR, \"alac: set_info failed\\n\");\n            return input_buffer_size;\n        }\n        alac->context_initialized = 1;\n    }\n    init_get_bits(&alac->gb, inbuffer, input_buffer_size * 8);\n    channels = get_bits(&alac->gb, 3) + 1;\n    if (channels > MAX_CHANNELS) {\n        av_log(avctx, AV_LOG_ERROR, \"channels > %d not supported\\n\",\n               MAX_CHANNELS);\n        return input_buffer_size;\n    }\n    skip_bits(&alac->gb, 4);\n    skip_bits(&alac->gb, 12);  \n    hassize = get_bits1(&alac->gb);\n    wasted_bytes = get_bits(&alac->gb, 2);  \n    isnotcompressed = get_bits1(&alac->gb);\n    if (hassize) {\n        outputsamples = get_bits_long(&alac->gb, 32);\n        if(outputsamples > alac->setinfo_max_samples_per_frame){\n            av_log(avctx, AV_LOG_ERROR, \"outputsamples %d > %d\\n\", outputsamples, alac->setinfo_max_samples_per_frame);\n            return -1;\n        }\n    } else\n        outputsamples = alac->setinfo_max_samples_per_frame;\n    if(outputsamples > *outputsize / alac->bytespersample){\n        av_log(avctx, AV_LOG_ERROR, \"sample buffer too small\\n\");\n        return -1;\n    }\n    *outputsize = outputsamples * alac->bytespersample;\n    readsamplesize = alac->setinfo_sample_size - (wasted_bytes * 8) + channels - 1;\n    if (!isnotcompressed) {\n        int16_t predictor_coef_table[channels][32];\n        int predictor_coef_num[channels];\n        int prediction_type[channels];\n        int prediction_quantitization[channels];\n        int ricemodifier[channels];\n        int i, chan;\n        interlacing_shift = get_bits(&alac->gb, 8);\n        interlacing_leftweight = get_bits(&alac->gb, 8);\n        for (chan = 0; chan < channels; chan++) {\n            prediction_type[chan] = get_bits(&alac->gb, 4);\n            prediction_quantitization[chan] = get_bits(&alac->gb, 4);\n            ricemodifier[chan] = get_bits(&alac->gb, 3);\n            predictor_coef_num[chan] = get_bits(&alac->gb, 5);\n            for (i = 0; i < predictor_coef_num[chan]; i++)\n                predictor_coef_table[chan][i] = (int16_t)get_bits(&alac->gb, 16);\n        }\n        if (wasted_bytes)\n            av_log(avctx, AV_LOG_ERROR, \"FIXME: unimplemented, unhandling of wasted_bytes\\n\");\n        for (chan = 0; chan < channels; chan++) {\n            bastardized_rice_decompress(alac,\n                                        alac->predicterror_buffer[chan],\n                                        outputsamples,\n                                        readsamplesize,\n                                        alac->setinfo_rice_initialhistory,\n                                        alac->setinfo_rice_kmodifier,\n                                        ricemodifier[chan] * alac->setinfo_rice_historymult / 4,\n                                        (1 << alac->setinfo_rice_kmodifier) - 1);\n            if (prediction_type[chan] == 0) {\n                predictor_decompress_fir_adapt(alac->predicterror_buffer[chan],\n                                               alac->outputsamples_buffer[chan],\n                                               outputsamples,\n                                               readsamplesize,\n                                               predictor_coef_table[chan],\n                                               predictor_coef_num[chan],\n                                               prediction_quantitization[chan]);\n            } else {\n                av_log(avctx, AV_LOG_ERROR, \"FIXME: unhandled prediction type: %i\\n\", prediction_type[chan]);\n            }\n        }\n    } else {\n        int i, chan;\n        for (i = 0; i < outputsamples; i++)\n            for (chan = 0; chan < channels; chan++) {\n                int32_t audiobits;\n                audiobits = get_bits_long(&alac->gb, alac->setinfo_sample_size);\n                audiobits = extend_sign32(audiobits, alac->setinfo_sample_size);\n                alac->outputsamples_buffer[chan][i] = audiobits;\n            }\n        interlacing_shift = 0;\n        interlacing_leftweight = 0;\n    }\n    if (get_bits(&alac->gb, 3) != 7)\n        av_log(avctx, AV_LOG_ERROR, \"Error : Wrong End Of Frame\\n\");\n    switch(alac->setinfo_sample_size) {\n    case 16:\n        if (channels == 2) {\n            reconstruct_stereo_16(alac->outputsamples_buffer,\n                                  (int16_t*)outbuffer,\n                                  alac->numchannels,\n                                  outputsamples,\n                                  interlacing_shift,\n                                  interlacing_leftweight);\n        } else {\n            int i;\n            for (i = 0; i < outputsamples; i++) {\n                int16_t sample = alac->outputsamples_buffer[0][i];\n                ((int16_t*)outbuffer)[i * alac->numchannels] = sample;\n            }\n        }\n        break;\n    case 20:\n    case 24:\n    case 32:\n        av_log(avctx, AV_LOG_ERROR, \"FIXME: unimplemented sample size %i\\n\", alac->setinfo_sample_size);\n        break;\n    default:\n        break;\n    }\n    if (input_buffer_size * 8 - get_bits_count(&alac->gb) > 8)\n        av_log(avctx, AV_LOG_ERROR, \"Error : %d bits left\\n\", input_buffer_size * 8 - get_bits_count(&alac->gb));\n    return input_buffer_size;\n}"}
{"idx": 24700, "func": "static void mptsas_scsi_init(PCIDevice *dev, Error **errp)\n{\n    DeviceState *d = DEVICE(dev);\n    MPTSASState *s = MPT_SAS(dev);\n    dev->config[PCI_LATENCY_TIMER] = 0;\n    dev->config[PCI_INTERRUPT_PIN] = 0x01;\n    memory_region_init_io(&s->mmio_io, OBJECT(s), &mptsas_mmio_ops, s,\n                          \"mptsas-mmio\", 0x4000);\n    memory_region_init_io(&s->port_io, OBJECT(s), &mptsas_port_ops, s,\n                          \"mptsas-io\", 256);\n    memory_region_init_io(&s->diag_io, OBJECT(s), &mptsas_diag_ops, s,\n                          \"mptsas-diag\", 0x10000);\n    if (s->msi != ON_OFF_AUTO_OFF &&\n        msi_init(dev, 0, 1, true, false) >= 0) {\n        s->msi_in_use = true;\n    }\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &s->port_io);\n    pci_register_bar(dev, 1, PCI_BASE_ADDRESS_SPACE_MEMORY |\n                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->mmio_io);\n    pci_register_bar(dev, 2, PCI_BASE_ADDRESS_SPACE_MEMORY |\n                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->diag_io);\n    if (!s->sas_addr) {\n        s->sas_addr = ((NAA_LOCALLY_ASSIGNED_ID << 24) |\n                       IEEE_COMPANY_LOCALLY_ASSIGNED) << 36;\n        s->sas_addr |= (pci_bus_num(dev->bus) << 16);\n        s->sas_addr |= (PCI_SLOT(dev->devfn) << 8);\n        s->sas_addr |= PCI_FUNC(dev->devfn);\n    }\n    s->max_devices = MPTSAS_NUM_PORTS;\n    s->request_bh = qemu_bh_new(mptsas_fetch_requests, s);\n    QTAILQ_INIT(&s->pending);\n    scsi_bus_new(&s->bus, sizeof(s->bus), &dev->qdev, &mptsas_scsi_info, NULL);\n    if (!d->hotplugged) {\n        scsi_bus_legacy_handle_cmdline(&s->bus, errp);\n    }\n}"}
{"idx": 24701, "func": "static inline int num_effective_busses(XilinxSPIPS *s)\n{\n    return (s->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS &&\n            s->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? s->num_busses : 1;\n}"}
{"idx": 24721, "func": "static int kvm_physical_sync_dirty_bitmap(target_phys_addr_t start_addr,\n                                          target_phys_addr_t end_addr)\n{\n    KVMState *s = kvm_state;\n    unsigned long size, allocated_size = 0;\n    KVMDirtyLog d;\n    KVMSlot *mem;\n    int ret = 0;\n    d.dirty_bitmap = NULL;\n    while (start_addr < end_addr) {\n        mem = kvm_lookup_overlapping_slot(s, start_addr, end_addr);\n        if (mem == NULL) {\n            break;\n        }\n        size = ALIGN(((mem->memory_size) >> TARGET_PAGE_BITS), HOST_LONG_BITS) / 8;\n        if (!d.dirty_bitmap) {\n            d.dirty_bitmap = qemu_malloc(size);\n        } else if (size > allocated_size) {\n            d.dirty_bitmap = qemu_realloc(d.dirty_bitmap, size);\n        }\n        allocated_size = size;\n        memset(d.dirty_bitmap, 0, allocated_size);\n        d.slot = mem->slot;\n        if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) == -1) {\n            DPRINTF(\"ioctl failed %d\\n\", errno);\n            ret = -1;\n            break;\n        }\n        kvm_get_dirty_pages_log_range(mem->start_addr, d.dirty_bitmap,\n                                      mem->start_addr, mem->memory_size);\n        start_addr = mem->start_addr + mem->memory_size;\n    }\n    qemu_free(d.dirty_bitmap);\n    return ret;\n}"}
{"idx": 24723, "func": "int main(void)\n{\n    int nf;\n    Suite *s;\n    SRunner *sr;\n    s = qfloat_suite();\n    sr = srunner_create(s);\n    srunner_run_all(sr, CK_NORMAL);\n    nf = srunner_ntests_failed(sr);\n    srunner_free(sr);\n    return (nf == 0) ? EXIT_SUCCESS : EXIT_FAILURE;\n}"}
{"idx": 24726, "func": "static inline void gen_op_arith_add(DisasContext *ctx, TCGv ret, TCGv arg1,\n                                    TCGv arg2, int add_ca, int compute_ca,\n                                    int compute_ov)\n{\n    TCGv t0, t1;\n    if ((!compute_ca && !compute_ov) ||\n        (!TCGV_EQUAL(ret,arg1) && !TCGV_EQUAL(ret, arg2)))  {\n        t0 = ret;\n    } else {\n        t0 = tcg_temp_local_new();\n    }\n    if (add_ca) {\n        t1 = tcg_temp_local_new();\n        tcg_gen_mov_tl(t1, cpu_ca);\n    } else {\n        TCGV_UNUSED(t1);\n    }\n    if (compute_ca) {\n        tcg_gen_movi_tl(cpu_ca, 0);\n    }\n    if (compute_ov) {\n        tcg_gen_movi_tl(cpu_ov, 0);\n    }\n    tcg_gen_add_tl(t0, arg1, arg2);\n    if (compute_ca) {\n        gen_op_arith_compute_ca(ctx, t0, arg1, 0);\n    }\n    if (add_ca) {\n        tcg_gen_add_tl(t0, t0, t1);\n        gen_op_arith_compute_ca(ctx, t0, t1, 0);\n        tcg_temp_free(t1);\n    }\n    if (compute_ov) {\n        gen_op_arith_compute_ov(ctx, t0, arg1, arg2, 0);\n    }\n    if (unlikely(Rc(ctx->opcode) != 0))\n        gen_set_Rc0(ctx, t0);\n    if (!TCGV_EQUAL(t0, ret)) {\n        tcg_gen_mov_tl(ret, t0);\n        tcg_temp_free(t0);\n    }\n}"}
{"idx": 24748, "func": "static int scsi_req_length(SCSIRequest *req, uint8_t *cmd)\n{\n    switch (cmd[0] >> 5) {\n    case 0:\n        req->cmd.xfer = cmd[4];\n        req->cmd.len = 6;\n        if (req->cmd.xfer == 0)\n            req->cmd.xfer = 256;\n        break;\n    case 1:\n    case 2:\n        req->cmd.xfer = cmd[8] | (cmd[7] << 8);\n        req->cmd.len = 10;\n        break;\n    case 4:\n        req->cmd.xfer = cmd[13] | (cmd[12] << 8) | (cmd[11] << 16) | (cmd[10] << 24);\n        req->cmd.len = 16;\n        break;\n    case 5:\n        req->cmd.xfer = cmd[9] | (cmd[8] << 8) | (cmd[7] << 16) | (cmd[6] << 24);\n        req->cmd.len = 12;\n        break;\n    default:\n        trace_scsi_req_parse_bad(req->dev->id, req->lun, req->tag, cmd[0]);\n        return -1;\n    }\n    switch(cmd[0]) {\n    case TEST_UNIT_READY:\n    case START_STOP:\n    case SEEK_6:\n    case WRITE_FILEMARKS:\n    case SPACE:\n    case RESERVE:\n    case RELEASE:\n    case ERASE:\n    case ALLOW_MEDIUM_REMOVAL:\n    case VERIFY:\n    case SEEK_10:\n    case SYNCHRONIZE_CACHE:\n    case LOCK_UNLOCK_CACHE:\n    case LOAD_UNLOAD:\n    case SET_CD_SPEED:\n    case SET_LIMITS:\n    case WRITE_LONG:\n    case MOVE_MEDIUM:\n    case UPDATE_BLOCK:\n        req->cmd.xfer = 0;\n        break;\n    case MODE_SENSE:\n        break;\n    case WRITE_SAME:\n        req->cmd.xfer = 1;\n        break;\n    case READ_CAPACITY:\n        req->cmd.xfer = 8;\n        break;\n    case READ_BLOCK_LIMITS:\n        req->cmd.xfer = 6;\n        break;\n    case READ_POSITION:\n        req->cmd.xfer = 20;\n        break;\n    case SEND_VOLUME_TAG:\n        req->cmd.xfer *= 40;\n        break;\n    case MEDIUM_SCAN:\n        req->cmd.xfer *= 8;\n        break;\n    case WRITE_10:\n    case WRITE_VERIFY:\n    case WRITE_6:\n    case WRITE_12:\n    case WRITE_VERIFY_12:\n    case WRITE_16:\n    case WRITE_VERIFY_16:\n        req->cmd.xfer *= req->dev->blocksize;\n        break;\n    case READ_10:\n    case READ_6:\n    case READ_REVERSE:\n    case RECOVER_BUFFERED_DATA:\n    case READ_12:\n    case READ_16:\n        req->cmd.xfer *= req->dev->blocksize;\n        break;\n    case INQUIRY:\n        req->cmd.xfer = cmd[4] | (cmd[3] << 8);\n        break;\n    case MAINTENANCE_OUT:\n    case MAINTENANCE_IN:\n        if (req->dev->type == TYPE_ROM) {\n            req->cmd.xfer = cmd[9] | (cmd[8] << 8);\n        }\n        break;\n    }\n    return 0;\n}"}
{"idx": 24760, "func": "void helper_store_fpcr (uint64_t val)\n{\n#ifdef CONFIG_SOFTFLOAT\n    set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS);\n#endif\n    switch ((val >> 58) & 3) {\n    case 0:\n        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);\n        break;\n    case 1:\n        set_float_rounding_mode(float_round_down, &FP_STATUS);\n        break;\n    case 2:\n        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);\n        break;\n    case 3:\n        set_float_rounding_mode(float_round_up, &FP_STATUS);\n        break;\n    }\n}"}
{"idx": 24773, "func": "void ff_rtsp_undo_setup(AVFormatContext *s, int send_packets)\n{\n    RTSPState *rt = s->priv_data;\n    int i;\n    for (i = 0; i < rt->nb_rtsp_streams; i++) {\n        RTSPStream *rtsp_st = rt->rtsp_streams[i];\n        if (!rtsp_st)\n            continue;\n        if (rtsp_st->transport_priv) {\n            if (s->oformat) {\n                AVFormatContext *rtpctx = rtsp_st->transport_priv;\n                av_write_trailer(rtpctx);\n                if (rt->lower_transport == RTSP_LOWER_TRANSPORT_TCP) {\n                    uint8_t *ptr;\n                    if (CONFIG_RTSP_MUXER && rtpctx->pb && send_packets)\n                        ff_rtsp_tcp_write_packet(s, rtsp_st);\n                    avio_close_dyn_buf(rtpctx->pb, &ptr);\n                    av_free(ptr);\n                } else {\n                    avio_close(rtpctx->pb);\n                }\n                avformat_free_context(rtpctx);\n            } else if (rt->transport == RTSP_TRANSPORT_RDT && CONFIG_RTPDEC)\n                ff_rdt_parse_close(rtsp_st->transport_priv);\n            else if (rt->transport == RTSP_TRANSPORT_RTP && CONFIG_RTPDEC)\n                ff_rtp_parse_close(rtsp_st->transport_priv);\n        }\n        rtsp_st->transport_priv = NULL;\n        if (rtsp_st->rtp_handle)\n            ffurl_close(rtsp_st->rtp_handle);\n        rtsp_st->rtp_handle = NULL;\n    }\n}"}
{"idx": 24776, "func": "static int kvm_get_msrs(X86CPU *cpu)\n{\n    CPUX86State *env = &cpu->env;\n    struct kvm_msr_entry *msrs = cpu->kvm_msr_buf->entries;\n    int ret, i;\n    uint64_t mtrr_top_bits;\n    kvm_msr_buf_reset(cpu);\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_CS, 0);\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_ESP, 0);\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_EIP, 0);\n    kvm_msr_entry_add(cpu, MSR_PAT, 0);\n    if (has_msr_star) {\n        kvm_msr_entry_add(cpu, MSR_STAR, 0);\n    }\n    if (has_msr_hsave_pa) {\n        kvm_msr_entry_add(cpu, MSR_VM_HSAVE_PA, 0);\n    }\n    if (has_msr_tsc_aux) {\n        kvm_msr_entry_add(cpu, MSR_TSC_AUX, 0);\n    }\n    if (has_msr_tsc_adjust) {\n        kvm_msr_entry_add(cpu, MSR_TSC_ADJUST, 0);\n    }\n    if (has_msr_tsc_deadline) {\n        kvm_msr_entry_add(cpu, MSR_IA32_TSCDEADLINE, 0);\n    }\n    if (has_msr_misc_enable) {\n        kvm_msr_entry_add(cpu, MSR_IA32_MISC_ENABLE, 0);\n    }\n    if (has_msr_smbase) {\n        kvm_msr_entry_add(cpu, MSR_IA32_SMBASE, 0);\n    }\n    if (has_msr_feature_control) {\n        kvm_msr_entry_add(cpu, MSR_IA32_FEATURE_CONTROL, 0);\n    }\n    if (has_msr_bndcfgs) {\n        kvm_msr_entry_add(cpu, MSR_IA32_BNDCFGS, 0);\n    }\n    if (has_msr_xss) {\n        kvm_msr_entry_add(cpu, MSR_IA32_XSS, 0);\n    }\n    if (!env->tsc_valid) {\n        kvm_msr_entry_add(cpu, MSR_IA32_TSC, 0);\n        env->tsc_valid = !runstate_is_running();\n    }\n#ifdef TARGET_X86_64\n    if (lm_capable_kernel) {\n        kvm_msr_entry_add(cpu, MSR_CSTAR, 0);\n        kvm_msr_entry_add(cpu, MSR_KERNELGSBASE, 0);\n        kvm_msr_entry_add(cpu, MSR_FMASK, 0);\n        kvm_msr_entry_add(cpu, MSR_LSTAR, 0);\n    }\n#endif\n    kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, 0);\n    kvm_msr_entry_add(cpu, MSR_KVM_WALL_CLOCK, 0);\n    if (has_msr_async_pf_en) {\n        kvm_msr_entry_add(cpu, MSR_KVM_ASYNC_PF_EN, 0);\n    }\n    if (has_msr_pv_eoi_en) {\n        kvm_msr_entry_add(cpu, MSR_KVM_PV_EOI_EN, 0);\n    }\n    if (has_msr_kvm_steal_time) {\n        kvm_msr_entry_add(cpu, MSR_KVM_STEAL_TIME, 0);\n    }\n    if (has_msr_architectural_pmu) {\n        kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, 0);\n        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, 0);\n        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS, 0);\n        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL, 0);\n        for (i = 0; i < MAX_FIXED_COUNTERS; i++) {\n            kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i, 0);\n        }\n        for (i = 0; i < num_architectural_pmu_counters; i++) {\n            kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i, 0);\n            kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i, 0);\n        }\n    }\n    if (env->mcg_cap) {\n        kvm_msr_entry_add(cpu, MSR_MCG_STATUS, 0);\n        kvm_msr_entry_add(cpu, MSR_MCG_CTL, 0);\n        if (has_msr_mcg_ext_ctl) {\n            kvm_msr_entry_add(cpu, MSR_MCG_EXT_CTL, 0);\n        }\n        for (i = 0; i < (env->mcg_cap & 0xff) * 4; i++) {\n            kvm_msr_entry_add(cpu, MSR_MC0_CTL + i, 0);\n        }\n    }\n    if (has_msr_hv_hypercall) {\n        kvm_msr_entry_add(cpu, HV_X64_MSR_HYPERCALL, 0);\n        kvm_msr_entry_add(cpu, HV_X64_MSR_GUEST_OS_ID, 0);\n    }\n    if (has_msr_hv_vapic) {\n        kvm_msr_entry_add(cpu, HV_X64_MSR_APIC_ASSIST_PAGE, 0);\n    }\n    if (has_msr_hv_tsc) {\n        kvm_msr_entry_add(cpu, HV_X64_MSR_REFERENCE_TSC, 0);\n    }\n    if (has_msr_hv_crash) {\n        int j;\n        for (j = 0; j < HV_X64_MSR_CRASH_PARAMS; j++) {\n            kvm_msr_entry_add(cpu, HV_X64_MSR_CRASH_P0 + j, 0);\n        }\n    }\n    if (has_msr_hv_runtime) {\n        kvm_msr_entry_add(cpu, HV_X64_MSR_VP_RUNTIME, 0);\n    }\n    if (cpu->hyperv_synic) {\n        uint32_t msr;\n        kvm_msr_entry_add(cpu, HV_X64_MSR_SCONTROL, 0);\n        kvm_msr_entry_add(cpu, HV_X64_MSR_SVERSION, 0);\n        kvm_msr_entry_add(cpu, HV_X64_MSR_SIEFP, 0);\n        kvm_msr_entry_add(cpu, HV_X64_MSR_SIMP, 0);\n        for (msr = HV_X64_MSR_SINT0; msr <= HV_X64_MSR_SINT15; msr++) {\n            kvm_msr_entry_add(cpu, msr, 0);\n        }\n    }\n    if (has_msr_hv_stimer) {\n        uint32_t msr;\n        for (msr = HV_X64_MSR_STIMER0_CONFIG; msr <= HV_X64_MSR_STIMER3_COUNT;\n             msr++) {\n            kvm_msr_entry_add(cpu, msr, 0);\n        }\n    }\n    if (has_msr_mtrr) {\n        kvm_msr_entry_add(cpu, MSR_MTRRdefType, 0);\n        kvm_msr_entry_add(cpu, MSR_MTRRfix64K_00000, 0);\n        kvm_msr_entry_add(cpu, MSR_MTRRfix16K_80000, 0);\n        kvm_msr_entry_add(cpu, MSR_MTRRfix16K_A0000, 0);\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C0000, 0);\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C8000, 0);\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D0000, 0);\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D8000, 0);\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E0000, 0);\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E8000, 0);\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F0000, 0);\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F8000, 0);\n        for (i = 0; i < MSR_MTRRcap_VCNT; i++) {\n            kvm_msr_entry_add(cpu, MSR_MTRRphysBase(i), 0);\n            kvm_msr_entry_add(cpu, MSR_MTRRphysMask(i), 0);\n        }\n    }\n    ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_MSRS, cpu->kvm_msr_buf);\n    if (ret < 0) {\n        return ret;\n    }\n    assert(ret == cpu->kvm_msr_buf->nmsrs);\n    if (cpu->fill_mtrr_mask) {\n        QEMU_BUILD_BUG_ON(TARGET_PHYS_ADDR_SPACE_BITS > 52);\n        assert(cpu->phys_bits <= TARGET_PHYS_ADDR_SPACE_BITS);\n        mtrr_top_bits = MAKE_64BIT_MASK(cpu->phys_bits, 52 - cpu->phys_bits);\n    } else {\n        mtrr_top_bits = 0;\n    }\n    for (i = 0; i < ret; i++) {\n        uint32_t index = msrs[i].index;\n        switch (index) {\n        case MSR_IA32_SYSENTER_CS:\n            env->sysenter_cs = msrs[i].data;\n            break;\n        case MSR_IA32_SYSENTER_ESP:\n            env->sysenter_esp = msrs[i].data;\n            break;\n        case MSR_IA32_SYSENTER_EIP:\n            env->sysenter_eip = msrs[i].data;\n            break;\n        case MSR_PAT:\n            env->pat = msrs[i].data;\n            break;\n        case MSR_STAR:\n            env->star = msrs[i].data;\n            break;\n#ifdef TARGET_X86_64\n        case MSR_CSTAR:\n            env->cstar = msrs[i].data;\n            break;\n        case MSR_KERNELGSBASE:\n            env->kernelgsbase = msrs[i].data;\n            break;\n        case MSR_FMASK:\n            env->fmask = msrs[i].data;\n            break;\n        case MSR_LSTAR:\n            env->lstar = msrs[i].data;\n            break;\n#endif\n        case MSR_IA32_TSC:\n            env->tsc = msrs[i].data;\n            break;\n        case MSR_TSC_AUX:\n            env->tsc_aux = msrs[i].data;\n            break;\n        case MSR_TSC_ADJUST:\n            env->tsc_adjust = msrs[i].data;\n            break;\n        case MSR_IA32_TSCDEADLINE:\n            env->tsc_deadline = msrs[i].data;\n            break;\n        case MSR_VM_HSAVE_PA:\n            env->vm_hsave = msrs[i].data;\n            break;\n        case MSR_KVM_SYSTEM_TIME:\n            env->system_time_msr = msrs[i].data;\n            break;\n        case MSR_KVM_WALL_CLOCK:\n            env->wall_clock_msr = msrs[i].data;\n            break;\n        case MSR_MCG_STATUS:\n            env->mcg_status = msrs[i].data;\n            break;\n        case MSR_MCG_CTL:\n            env->mcg_ctl = msrs[i].data;\n            break;\n        case MSR_MCG_EXT_CTL:\n            env->mcg_ext_ctl = msrs[i].data;\n            break;\n        case MSR_IA32_MISC_ENABLE:\n            env->msr_ia32_misc_enable = msrs[i].data;\n            break;\n        case MSR_IA32_SMBASE:\n            env->smbase = msrs[i].data;\n            break;\n        case MSR_IA32_FEATURE_CONTROL:\n            env->msr_ia32_feature_control = msrs[i].data;\n            break;\n        case MSR_IA32_BNDCFGS:\n            env->msr_bndcfgs = msrs[i].data;\n            break;\n        case MSR_IA32_XSS:\n            env->xss = msrs[i].data;\n            break;\n        default:\n            if (msrs[i].index >= MSR_MC0_CTL &&\n                msrs[i].index < MSR_MC0_CTL + (env->mcg_cap & 0xff) * 4) {\n                env->mce_banks[msrs[i].index - MSR_MC0_CTL] = msrs[i].data;\n            }\n            break;\n        case MSR_KVM_ASYNC_PF_EN:\n            env->async_pf_en_msr = msrs[i].data;\n            break;\n        case MSR_KVM_PV_EOI_EN:\n            env->pv_eoi_en_msr = msrs[i].data;\n            break;\n        case MSR_KVM_STEAL_TIME:\n            env->steal_time_msr = msrs[i].data;\n            break;\n        case MSR_CORE_PERF_FIXED_CTR_CTRL:\n            env->msr_fixed_ctr_ctrl = msrs[i].data;\n            break;\n        case MSR_CORE_PERF_GLOBAL_CTRL:\n            env->msr_global_ctrl = msrs[i].data;\n            break;\n        case MSR_CORE_PERF_GLOBAL_STATUS:\n            env->msr_global_status = msrs[i].data;\n            break;\n        case MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n            env->msr_global_ovf_ctrl = msrs[i].data;\n            break;\n        case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR0 + MAX_FIXED_COUNTERS - 1:\n            env->msr_fixed_counters[index - MSR_CORE_PERF_FIXED_CTR0] = msrs[i].data;\n            break;\n        case MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR0 + MAX_GP_COUNTERS - 1:\n            env->msr_gp_counters[index - MSR_P6_PERFCTR0] = msrs[i].data;\n            break;\n        case MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL0 + MAX_GP_COUNTERS - 1:\n            env->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = msrs[i].data;\n            break;\n        case HV_X64_MSR_HYPERCALL:\n            env->msr_hv_hypercall = msrs[i].data;\n            break;\n        case HV_X64_MSR_GUEST_OS_ID:\n            env->msr_hv_guest_os_id = msrs[i].data;\n            break;\n        case HV_X64_MSR_APIC_ASSIST_PAGE:\n            env->msr_hv_vapic = msrs[i].data;\n            break;\n        case HV_X64_MSR_REFERENCE_TSC:\n            env->msr_hv_tsc = msrs[i].data;\n            break;\n        case HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n            env->msr_hv_crash_params[index - HV_X64_MSR_CRASH_P0] = msrs[i].data;\n            break;\n        case HV_X64_MSR_VP_RUNTIME:\n            env->msr_hv_runtime = msrs[i].data;\n            break;\n        case HV_X64_MSR_SCONTROL:\n            env->msr_hv_synic_control = msrs[i].data;\n            break;\n        case HV_X64_MSR_SVERSION:\n            env->msr_hv_synic_version = msrs[i].data;\n            break;\n        case HV_X64_MSR_SIEFP:\n            env->msr_hv_synic_evt_page = msrs[i].data;\n            break;\n        case HV_X64_MSR_SIMP:\n            env->msr_hv_synic_msg_page = msrs[i].data;\n            break;\n        case HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n            env->msr_hv_synic_sint[index - HV_X64_MSR_SINT0] = msrs[i].data;\n            break;\n        case HV_X64_MSR_STIMER0_CONFIG:\n        case HV_X64_MSR_STIMER1_CONFIG:\n        case HV_X64_MSR_STIMER2_CONFIG:\n        case HV_X64_MSR_STIMER3_CONFIG:\n            env->msr_hv_stimer_config[(index - HV_X64_MSR_STIMER0_CONFIG)/2] =\n                                msrs[i].data;\n            break;\n        case HV_X64_MSR_STIMER0_COUNT:\n        case HV_X64_MSR_STIMER1_COUNT:\n        case HV_X64_MSR_STIMER2_COUNT:\n        case HV_X64_MSR_STIMER3_COUNT:\n            env->msr_hv_stimer_count[(index - HV_X64_MSR_STIMER0_COUNT)/2] =\n                                msrs[i].data;\n            break;\n        case MSR_MTRRdefType:\n            env->mtrr_deftype = msrs[i].data;\n            break;\n        case MSR_MTRRfix64K_00000:\n            env->mtrr_fixed[0] = msrs[i].data;\n            break;\n        case MSR_MTRRfix16K_80000:\n            env->mtrr_fixed[1] = msrs[i].data;\n            break;\n        case MSR_MTRRfix16K_A0000:\n            env->mtrr_fixed[2] = msrs[i].data;\n            break;\n        case MSR_MTRRfix4K_C0000:\n            env->mtrr_fixed[3] = msrs[i].data;\n            break;\n        case MSR_MTRRfix4K_C8000:\n            env->mtrr_fixed[4] = msrs[i].data;\n            break;\n        case MSR_MTRRfix4K_D0000:\n            env->mtrr_fixed[5] = msrs[i].data;\n            break;\n        case MSR_MTRRfix4K_D8000:\n            env->mtrr_fixed[6] = msrs[i].data;\n            break;\n        case MSR_MTRRfix4K_E0000:\n            env->mtrr_fixed[7] = msrs[i].data;\n            break;\n        case MSR_MTRRfix4K_E8000:\n            env->mtrr_fixed[8] = msrs[i].data;\n            break;\n        case MSR_MTRRfix4K_F0000:\n            env->mtrr_fixed[9] = msrs[i].data;\n            break;\n        case MSR_MTRRfix4K_F8000:\n            env->mtrr_fixed[10] = msrs[i].data;\n            break;\n        case MSR_MTRRphysBase(0) ... MSR_MTRRphysMask(MSR_MTRRcap_VCNT - 1):\n            if (index & 1) {\n                env->mtrr_var[MSR_MTRRphysIndex(index)].mask = msrs[i].data |\n                                                               mtrr_top_bits;\n            } else {\n                env->mtrr_var[MSR_MTRRphysIndex(index)].base = msrs[i].data;\n            }\n            break;\n        }\n    }\n    return 0;\n}"}
{"idx": 24782, "func": "static av_always_inline void rv40_strong_loop_filter(uint8_t *src,\n                                                     const int step,\n                                                     const int stride,\n                                                     const int alpha,\n                                                     const int lims,\n                                                     const int dmode,\n                                                     const int chroma)\n{\n    int i;\n    for(i = 0; i < 4; i++, src += stride){\n        int sflag, p0, q0, p1, q1;\n        int t = src[0*step] - src[-1*step];\n        if (!t)\n            continue;\n        sflag = (alpha * FFABS(t)) >> 7;\n        if (sflag > 1)\n            continue;\n        p0 = (25*src[-3*step] + 26*src[-2*step] + 26*src[-1*step] +\n              26*src[ 0*step] + 25*src[ 1*step] +\n              rv40_dither_l[dmode + i]) >> 7;\n        q0 = (25*src[-2*step] + 26*src[-1*step] + 26*src[ 0*step] +\n              26*src[ 1*step] + 25*src[ 2*step] +\n              rv40_dither_r[dmode + i]) >> 7;\n        if (sflag) {\n            p0 = av_clip(p0, src[-1*step] - lims, src[-1*step] + lims);\n            q0 = av_clip(q0, src[ 0*step] - lims, src[ 0*step] + lims);\n        }\n        p1 = (25*src[-4*step] + 26*src[-3*step] + 26*src[-2*step] + 26*p0 +\n              25*src[ 0*step] + rv40_dither_l[dmode + i]) >> 7;\n        q1 = (25*src[-1*step] + 26*q0 + 26*src[ 1*step] + 26*src[ 2*step] +\n              25*src[ 3*step] + rv40_dither_r[dmode + i]) >> 7;\n        if (sflag) {\n            p1 = av_clip(p1, src[-2*step] - lims, src[-2*step] + lims);\n            q1 = av_clip(q1, src[ 1*step] - lims, src[ 1*step] + lims);\n        }\n        src[-2*step] = p1;\n        src[-1*step] = p0;\n        src[ 0*step] = q0;\n        src[ 1*step] = q1;\n        if(!chroma){\n            src[-3*step] = (25*src[-1*step] + 26*src[-2*step] +\n                            51*src[-3*step] + 26*src[-4*step] + 64) >> 7;\n            src[ 2*step] = (25*src[ 0*step] + 26*src[ 1*step] +\n                            51*src[ 2*step] + 26*src[ 3*step] + 64) >> 7;\n        }\n    }\n}"}
{"idx": 24791, "func": "static int ffserver_save_avoption(const char *opt, const char *arg, int type, FFServerConfig *config)\n{\n    static int hinted = 0;\n    int ret = 0;\n    AVDictionaryEntry *e;\n    const AVOption *o = NULL;\n    const char *option = NULL;\n    const char *codec_name = NULL;\n    char buff[1024];\n    AVCodecContext *ctx;\n    AVDictionary **dict;\n    enum AVCodecID guessed_codec_id;\n    switch (type) {\n    case AV_OPT_FLAG_VIDEO_PARAM:\n        ctx = config->dummy_vctx;\n        dict = &config->video_opts;\n        guessed_codec_id = config->guessed_video_codec_id != AV_CODEC_ID_NONE ?\n                           config->guessed_video_codec_id : AV_CODEC_ID_H264;\n        break;\n    case AV_OPT_FLAG_AUDIO_PARAM:\n        ctx = config->dummy_actx;\n        dict = &config->audio_opts;\n        guessed_codec_id = config->guessed_audio_codec_id != AV_CODEC_ID_NONE ?\n                           config->guessed_audio_codec_id : AV_CODEC_ID_AAC;\n        break;\n    default:\n        av_assert0(0);\n    }\n    if (strchr(opt, ':')) {\n        snprintf(buff, sizeof(buff), \"%s\", opt);\n        codec_name = buff;\n        option = strchr(buff, ':');\n        buff[option - buff] = '\\0';\n        option++;\n        if ((ret = ffserver_set_codec(ctx, codec_name, config)) < 0)\n            return ret;\n        if (!ctx->codec || !ctx->priv_data)\n            return -1;\n    } else {\n        option = opt;\n    }\n    o = av_opt_find(ctx, option, NULL, type | AV_OPT_FLAG_ENCODING_PARAM, AV_OPT_SEARCH_CHILDREN);\n    if (!o && (!strcmp(option, \"time_base\")  || !strcmp(option, \"pixel_format\") ||\n               !strcmp(option, \"video_size\") || !strcmp(option, \"codec_tag\")))\n        o = av_opt_find(ctx, option, NULL, 0, 0);\n    if (!o) {\n        report_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n                            &config->errors, \"Option not found: %s\\n\", opt);\n        if (!hinted && ctx->codec_id == AV_CODEC_ID_NONE) {\n            hinted = 1;\n            report_config_error(config->filename, config->line_num, AV_LOG_ERROR, NULL,\n                                \"If '%s' is a codec private option, then prefix it with codec name, \"\n                                \"for example '%s:%s %s' or define codec earlier.\\n\",\n                                opt, avcodec_get_name(guessed_codec_id) ,opt, arg);\n        }\n    } else if ((ret = av_opt_set(ctx, option, arg, AV_OPT_SEARCH_CHILDREN)) < 0) {\n        report_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n                &config->errors, \"Invalid value for option %s (%s): %s\\n\", opt,\n                arg, av_err2str(ret));\n    } else if ((e = av_dict_get(*dict, option, NULL, 0))) {\n        if ((o->type == AV_OPT_TYPE_FLAGS) && arg && (arg[0] == '+' || arg[0] == '-'))\n            return av_dict_set(dict, option, arg, AV_DICT_APPEND);\n        report_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n                &config->errors,\n                \"Redeclaring value of the option %s, previous value: %s\\n\",\n                opt, e->value);\n    } else if (av_dict_set(dict, option, arg, 0) < 0) {\n        return AVERROR(ENOMEM);\n    }\n    return 0;\n}"}
{"idx": 24792, "func": "static int decode_opc(MoxieCPU *cpu, DisasContext *ctx)\n{\n    CPUMoxieState *env = &cpu->env;\n    int opcode;\n    int length = 2;\n    if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) {\n        tcg_gen_debug_insn_start(ctx->pc);\n    }\n    opcode = ctx->opcode;\n    if (opcode & (1 << 15)) {\n        if (opcode & (1 << 14)) {\n            int inst = (opcode >> 10 & 0xf);\n#define BRANCH(cond)                                                         \\\n    do {                                                                     \\\n        int l1 = gen_new_label();                                            \\\n        tcg_gen_brcond_i32(cond, cc_a, cc_b, l1);                            \\\n        gen_goto_tb(env, ctx, 1, ctx->pc+2);                                 \\\n        gen_set_label(l1);                                                   \\\n        gen_goto_tb(env, ctx, 0, extract_branch_offset(opcode) + ctx->pc+2); \\\n        ctx->bstate = BS_BRANCH;                                             \\\n    } while (0)\n            switch (inst) {\n            case 0x00:  \n                BRANCH(TCG_COND_EQ);\n                break;\n            case 0x01:  \n                BRANCH(TCG_COND_NE);\n                break;\n            case 0x02:  \n                BRANCH(TCG_COND_LT);\n                break;\n            case 0x03:  \n                BRANCH(TCG_COND_GT);\n                break;\n            case 0x04:  \n                BRANCH(TCG_COND_LTU);\n                break;\n            case 0x05:  \n                BRANCH(TCG_COND_GTU);\n                break;\n            case 0x06:  \n                BRANCH(TCG_COND_GE);\n                break;\n            case 0x07:  \n                BRANCH(TCG_COND_LE);\n                break;\n            case 0x08:  \n                BRANCH(TCG_COND_GEU);\n                break;\n            case 0x09:  \n                BRANCH(TCG_COND_LEU);\n                break;\n            default:\n                {\n                    TCGv temp = tcg_temp_new_i32();\n                    tcg_gen_movi_i32(cpu_pc, ctx->pc);\n                    tcg_gen_movi_i32(temp, MOXIE_EX_BAD);\n                    gen_helper_raise_exception(cpu_env, temp);\n                    tcg_temp_free_i32(temp);\n                }\n                break;\n            }\n        } else {\n            int inst = (opcode >> 12 & 0x3);\n            switch (inst) {\n            case 0x00:  \n                {\n                    int a = (opcode >> 8) & 0xf;\n                    unsigned int v = (opcode & 0xff);\n                    tcg_gen_addi_i32(REG(a), REG(a), v);\n                }\n                break;\n            case 0x01:  \n                {\n                    int a = (opcode >> 8) & 0xf;\n                    unsigned int v = (opcode & 0xff);\n                    tcg_gen_subi_i32(REG(a), REG(a), v);\n                }\n                break;\n            case 0x02:  \n                {\n                    int a = (opcode >> 8) & 0xf;\n                    unsigned v = (opcode & 0xff);\n                    tcg_gen_ld_i32(REG(a), cpu_env,\n                                   offsetof(CPUMoxieState, sregs[v]));\n                }\n                break;\n            case 0x03:  \n                {\n                    int a = (opcode >> 8) & 0xf;\n                    unsigned v = (opcode & 0xff);\n                    tcg_gen_st_i32(REG(a), cpu_env,\n                                   offsetof(CPUMoxieState, sregs[v]));\n                }\n                break;\n            default:\n                {\n                    TCGv temp = tcg_temp_new_i32();\n                    tcg_gen_movi_i32(cpu_pc, ctx->pc);\n                    tcg_gen_movi_i32(temp, MOXIE_EX_BAD);\n                    gen_helper_raise_exception(cpu_env, temp);\n                    tcg_temp_free_i32(temp);\n                }\n                break;\n            }\n        }\n    } else {\n        int inst = opcode >> 8;\n        switch (inst) {\n        case 0x00:  \n            break;\n        case 0x01:  \n            {\n                int reg = (opcode >> 4) & 0xf;\n                int val = cpu_ldl_code(env, ctx->pc+2);\n                tcg_gen_movi_i32(REG(reg), val);\n                length = 6;\n            }\n            break;\n        case 0x02:  \n            {\n                int dest  = (opcode >> 4) & 0xf;\n                int src = opcode & 0xf;\n                tcg_gen_mov_i32(REG(dest), REG(src));\n            }\n            break;\n        case 0x03:  \n            {\n                TCGv t1 = tcg_temp_new_i32();\n                TCGv t2 = tcg_temp_new_i32();\n                tcg_gen_movi_i32(t1, ctx->pc + 6);\n                tcg_gen_subi_i32(t2, REG(1), 8);\n                tcg_gen_mov_i32(REG(1), t2);\n                tcg_gen_qemu_st32(t1, REG(1), ctx->memidx);\n                tcg_gen_subi_i32(t2, REG(1), 4);\n                tcg_gen_mov_i32(REG(1), t2);\n                tcg_gen_qemu_st32(REG(0), REG(1), ctx->memidx);\n                tcg_gen_mov_i32(REG(0), REG(1));\n                gen_goto_tb(env, ctx, 0, cpu_ldl_code(env, ctx->pc+2));\n                tcg_temp_free_i32(t1);\n                tcg_temp_free_i32(t2);\n                ctx->bstate = BS_BRANCH;\n                length = 6;\n            }\n            break;\n        case 0x04:  \n            {\n                TCGv t1 = tcg_temp_new_i32();\n                tcg_gen_mov_i32(REG(1), REG(0));\n                tcg_gen_qemu_ld32u(REG(0), REG(1), ctx->memidx);\n                tcg_gen_addi_i32(t1, REG(1), 4);\n                tcg_gen_mov_i32(REG(1), t1);\n                tcg_gen_qemu_ld32u(cpu_pc, REG(1), ctx->memidx);\n                tcg_gen_addi_i32(t1, REG(1), 8);\n                tcg_gen_mov_i32(REG(1), t1);\n                tcg_temp_free_i32(t1);\n                tcg_gen_exit_tb(0);\n                ctx->bstate = BS_BRANCH;\n            }\n            break;\n        case 0x05:  \n            {\n                int a = (opcode >> 4) & 0xf;\n                int b = opcode & 0xf;\n                tcg_gen_add_i32(REG(a), REG(a), REG(b));\n            }\n            break;\n        case 0x06:  \n            {\n                int a = (opcode >> 4) & 0xf;\n                int b = opcode & 0xf;\n                TCGv t1 = tcg_temp_new_i32();\n                tcg_gen_subi_i32(t1, REG(a), 4);\n                tcg_gen_mov_i32(REG(a), t1);\n                tcg_gen_qemu_st32(REG(b), REG(a), ctx->memidx);\n                tcg_temp_free_i32(t1);\n            }\n            break;\n        case 0x07:  \n            {\n                int a = (opcode >> 4) & 0xf;\n                int b = opcode & 0xf;\n                TCGv t1 = tcg_temp_new_i32();\n                tcg_gen_qemu_ld32u(REG(b), REG(a), ctx->memidx);\n                tcg_gen_addi_i32(t1, REG(a), 4);\n                tcg_gen_mov_i32(REG(a), t1);\n                tcg_temp_free_i32(t1);\n            }\n            break;\n        case 0x08:  \n            {\n                int reg = (opcode >> 4) & 0xf;\n                TCGv ptr = tcg_temp_new_i32();\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n                tcg_gen_qemu_ld32u(REG(reg), ptr, ctx->memidx);\n                tcg_temp_free_i32(ptr);\n                length = 6;\n            }\n            break;\n        case 0x09:  \n            {\n                int val = (opcode >> 4) & 0xf;\n                TCGv ptr = tcg_temp_new_i32();\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n                tcg_gen_qemu_st32(REG(val), ptr, ctx->memidx);\n                tcg_temp_free_i32(ptr);\n                length = 6;\n            }\n            break;\n        case 0x0a:  \n            {\n                int src  = opcode & 0xf;\n                int dest = (opcode >> 4) & 0xf;\n                tcg_gen_qemu_ld32u(REG(dest), REG(src), ctx->memidx);\n            }\n            break;\n        case 0x0b:  \n            {\n                int dest = (opcode >> 4) & 0xf;\n                int val  = opcode & 0xf;\n                tcg_gen_qemu_st32(REG(val), REG(dest), ctx->memidx);\n            }\n            break;\n        case 0x0c:  \n            {\n                int a = (opcode >> 4) & 0xf;\n                int b = opcode & 0xf;\n                TCGv t1 = tcg_temp_new_i32();\n                TCGv t2 = tcg_temp_new_i32();\n                tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(env, ctx->pc+2));\n                tcg_gen_qemu_ld32u(t2, t1, ctx->memidx);\n                tcg_gen_mov_i32(REG(a), t2);\n                tcg_temp_free_i32(t1);\n                tcg_temp_free_i32(t2);\n                length = 6;\n            }\n            break;\n        case 0x0d:  \n            {\n                int a = (opcode >> 4) & 0xf;\n                int b = opcode & 0xf;\n                TCGv t1 = tcg_temp_new_i32();\n                TCGv t2 = tcg_temp_new_i32();\n                tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(env, ctx->pc+2));\n                tcg_gen_qemu_st32(REG(b), t1, ctx->memidx);\n                tcg_temp_free_i32(t1);\n                tcg_temp_free_i32(t2);\n                length = 6;\n            }\n            break;\n        case 0x0e:  \n            {\n                int a  = (opcode >> 4) & 0xf;\n                int b  = opcode & 0xf;\n                tcg_gen_mov_i32(cc_a, REG(a));\n                tcg_gen_mov_i32(cc_b, REG(b));\n            }\n            break;\n        case 0x19:  \n            {\n                int fnreg = (opcode >> 4) & 0xf;\n                TCGv t1 = tcg_temp_new_i32();\n                TCGv t2 = tcg_temp_new_i32();\n                tcg_gen_movi_i32(t1, ctx->pc+2);\n                tcg_gen_subi_i32(t2, REG(1), 8);\n                tcg_gen_mov_i32(REG(1), t2);\n                tcg_gen_qemu_st32(t1, REG(1), ctx->memidx);\n                tcg_gen_subi_i32(t2, REG(1), 4);\n                tcg_gen_mov_i32(REG(1), t2);\n                tcg_gen_qemu_st32(REG(0), REG(1), ctx->memidx);\n                tcg_gen_mov_i32(REG(0), REG(1));\n                tcg_gen_mov_i32(cpu_pc, REG(fnreg));\n                tcg_temp_free_i32(t1);\n                tcg_temp_free_i32(t2);\n                tcg_gen_exit_tb(0);\n                ctx->bstate = BS_BRANCH;\n            }\n            break;\n        case 0x1a:  \n            {\n                tcg_gen_movi_i32(cpu_pc, cpu_ldl_code(env, ctx->pc+2));\n                tcg_gen_exit_tb(0);\n                ctx->bstate = BS_BRANCH;\n                length = 6;\n            }\n            break;\n        case 0x1b:  \n            {\n                int reg = (opcode >> 4) & 0xf;\n                int val = cpu_ldl_code(env, ctx->pc+2);\n                tcg_gen_movi_i32(REG(reg), val);\n                length = 6;\n            }\n            break;\n        case 0x1c:  \n            {\n                int src  = opcode & 0xf;\n                int dest = (opcode >> 4) & 0xf;\n                tcg_gen_qemu_ld8u(REG(dest), REG(src), ctx->memidx);\n            }\n            break;\n        case 0x1d:  \n            {\n                int reg = (opcode >> 4) & 0xf;\n                TCGv ptr = tcg_temp_new_i32();\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n                tcg_gen_qemu_ld8u(REG(reg), ptr, ctx->memidx);\n                tcg_temp_free_i32(ptr);\n                length = 6;\n            }\n            break;\n        case 0x1e:  \n            {\n                int dest = (opcode >> 4) & 0xf;\n                int val  = opcode & 0xf;\n                tcg_gen_qemu_st8(REG(val), REG(dest), ctx->memidx);\n            }\n            break;\n        case 0x1f:  \n            {\n                int val = (opcode >> 4) & 0xf;\n                TCGv ptr = tcg_temp_new_i32();\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n                tcg_gen_qemu_st8(REG(val), ptr, ctx->memidx);\n                tcg_temp_free_i32(ptr);\n                length = 6;\n            }\n            break;\n        case 0x20:  \n            {\n                int reg = (opcode >> 4) & 0xf;\n                int val = cpu_ldl_code(env, ctx->pc+2);\n                tcg_gen_movi_i32(REG(reg), val);\n                length = 6;\n            }\n            break;\n        case 0x21:  \n            {\n                int src  = opcode & 0xf;\n                int dest = (opcode >> 4) & 0xf;\n                tcg_gen_qemu_ld16u(REG(dest), REG(src), ctx->memidx);\n            }\n            break;\n        case 0x22:  \n            {\n                int reg = (opcode >> 4) & 0xf;\n                TCGv ptr = tcg_temp_new_i32();\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n                tcg_gen_qemu_ld16u(REG(reg), ptr, ctx->memidx);\n                tcg_temp_free_i32(ptr);\n                length = 6;\n            }\n            break;\n        case 0x23:  \n            {\n                int dest = (opcode >> 4) & 0xf;\n                int val  = opcode & 0xf;\n                tcg_gen_qemu_st16(REG(val), REG(dest), ctx->memidx);\n            }\n            break;\n        case 0x24:  \n            {\n                int val = (opcode >> 4) & 0xf;\n                TCGv ptr = tcg_temp_new_i32();\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n                tcg_gen_qemu_st16(REG(val), ptr, ctx->memidx);\n                tcg_temp_free_i32(ptr);\n                length = 6;\n            }\n            break;\n        case 0x25:  \n            {\n                int reg = (opcode >> 4) & 0xf;\n                tcg_gen_mov_i32(cpu_pc, REG(reg));\n                tcg_gen_exit_tb(0);\n                ctx->bstate = BS_BRANCH;\n            }\n            break;\n        case 0x26:  \n            {\n                int a = (opcode >> 4) & 0xf;\n                int b = opcode & 0xf;\n                tcg_gen_and_i32(REG(a), REG(a), REG(b));\n            }\n            break;\n        case 0x27:  \n            {\n                int a = (opcode >> 4) & 0xf;\n                int b = opcode & 0xf;\n                TCGv sv = tcg_temp_new_i32();\n                tcg_gen_andi_i32(sv, REG(b), 0x1f);\n                tcg_gen_shr_i32(REG(a), REG(a), sv);\n                tcg_temp_free_i32(sv);\n            }\n            break;\n        case 0x28:  \n            {\n                int a = (opcode >> 4) & 0xf;\n                int b = opcode & 0xf;\n                TCGv sv = tcg_temp_new_i32();\n                tcg_gen_andi_i32(sv, REG(b), 0x1f);\n                tcg_gen_shl_i32(REG(a), REG(a), sv);\n                tcg_temp_free_i32(sv);\n            }\n            break;\n        case 0x29:  \n            {\n                int a = (opcode >> 4) & 0xf;\n                int b = opcode & 0xf;\n                tcg_gen_sub_i32(REG(a), REG(a), REG(b));\n            }\n            break;\n        case 0x2a:  \n            {\n                int a = (opcode >> 4) & 0xf;\n                int b = opcode & 0xf;\n                tcg_gen_neg_i32(REG(a), REG(b));\n            }\n            break;\n        case 0x2b:  \n            {\n                int a = (opcode >> 4) & 0xf;\n                int b = opcode & 0xf;\n                tcg_gen_or_i32(REG(a), REG(a), REG(b));\n            }\n            break;\n        case 0x2c:  \n            {\n                int a = (opcode >> 4) & 0xf;\n                int b = opcode & 0xf;\n                tcg_gen_not_i32(REG(a), REG(b));\n            }\n            break;\n        case 0x2d:  \n            {\n                int a = (opcode >> 4) & 0xf;\n                int b = opcode & 0xf;\n                TCGv sv = tcg_temp_new_i32();\n                tcg_gen_andi_i32(sv, REG(b), 0x1f);\n                tcg_gen_sar_i32(REG(a), REG(a), sv);\n                tcg_temp_free_i32(sv);\n            }\n            break;\n        case 0x2e:  \n            {\n                int a = (opcode >> 4) & 0xf;\n                int b = opcode & 0xf;\n                tcg_gen_xor_i32(REG(a), REG(a), REG(b));\n            }\n            break;\n        case 0x2f:  \n            {\n                int a = (opcode >> 4) & 0xf;\n                int b = opcode & 0xf;\n                tcg_gen_mul_i32(REG(a), REG(a), REG(b));\n            }\n            break;\n        case 0x30:  \n            {\n                int val = cpu_ldl_code(env, ctx->pc+2);\n                TCGv temp = tcg_temp_new_i32();\n                tcg_gen_movi_i32(temp, val);\n                tcg_gen_st_i32(temp, cpu_env,\n                               offsetof(CPUMoxieState, sregs[3]));\n                tcg_gen_movi_i32(cpu_pc, ctx->pc);\n                tcg_gen_movi_i32(temp, MOXIE_EX_SWI);\n                gen_helper_raise_exception(cpu_env, temp);\n                tcg_temp_free_i32(temp);\n                length = 6;\n            }\n            break;\n        case 0x31:  \n            {\n                int a = (opcode >> 4) & 0xf;\n                int b = opcode & 0xf;\n                tcg_gen_movi_i32(cpu_pc, ctx->pc);\n                gen_helper_div(REG(a), cpu_env, REG(a), REG(b));\n            }\n            break;\n        case 0x32:  \n            {\n                int a = (opcode >> 4) & 0xf;\n                int b = opcode & 0xf;\n                tcg_gen_movi_i32(cpu_pc, ctx->pc);\n                gen_helper_udiv(REG(a), cpu_env, REG(a), REG(b));\n            }\n            break;\n        case 0x33:  \n            {\n                int a = (opcode >> 4) & 0xf;\n                int b = opcode & 0xf;\n                tcg_gen_rem_i32(REG(a), REG(a), REG(b));\n            }\n            break;\n        case 0x34:  \n            {\n                int a = (opcode >> 4) & 0xf;\n                int b = opcode & 0xf;\n                tcg_gen_remu_i32(REG(a), REG(a), REG(b));\n            }\n            break;\n        case 0x35:  \n            {\n                TCGv temp = tcg_temp_new_i32();\n                tcg_gen_movi_i32(cpu_pc, ctx->pc);\n                tcg_gen_movi_i32(temp, MOXIE_EX_BREAK);\n                gen_helper_raise_exception(cpu_env, temp);\n                tcg_temp_free_i32(temp);\n            }\n            break;\n        case 0x36:  \n            {\n                int a = (opcode >> 4) & 0xf;\n                int b = opcode & 0xf;\n                TCGv t1 = tcg_temp_new_i32();\n                TCGv t2 = tcg_temp_new_i32();\n                tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(env, ctx->pc+2));\n                tcg_gen_qemu_ld8u(t2, t1, ctx->memidx);\n                tcg_gen_mov_i32(REG(a), t2);\n                tcg_temp_free_i32(t1);\n                tcg_temp_free_i32(t2);\n                length = 6;\n            }\n            break;\n        case 0x37:  \n            {\n                int a = (opcode >> 4) & 0xf;\n                int b = opcode & 0xf;\n                TCGv t1 = tcg_temp_new_i32();\n                TCGv t2 = tcg_temp_new_i32();\n                tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(env, ctx->pc+2));\n                tcg_gen_qemu_st8(REG(b), t1, ctx->memidx);\n                tcg_temp_free_i32(t1);\n                tcg_temp_free_i32(t2);\n                length = 6;\n            }\n            break;\n        case 0x38:  \n            {\n                int a = (opcode >> 4) & 0xf;\n                int b = opcode & 0xf;\n                TCGv t1 = tcg_temp_new_i32();\n                TCGv t2 = tcg_temp_new_i32();\n                tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(env, ctx->pc+2));\n                tcg_gen_qemu_ld16u(t2, t1, ctx->memidx);\n                tcg_gen_mov_i32(REG(a), t2);\n                tcg_temp_free_i32(t1);\n                tcg_temp_free_i32(t2);\n                length = 6;\n            }\n            break;\n        case 0x39:  \n            {\n                int a = (opcode >> 4) & 0xf;\n                int b = opcode & 0xf;\n                TCGv t1 = tcg_temp_new_i32();\n                TCGv t2 = tcg_temp_new_i32();\n                tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(env, ctx->pc+2));\n                tcg_gen_qemu_st16(REG(b), t1, ctx->memidx);\n                tcg_temp_free_i32(t1);\n                tcg_temp_free_i32(t2);\n                length = 6;\n            }\n            break;\n        default:\n            {\n                TCGv temp = tcg_temp_new_i32();\n                tcg_gen_movi_i32(cpu_pc, ctx->pc);\n                tcg_gen_movi_i32(temp, MOXIE_EX_BAD);\n                gen_helper_raise_exception(cpu_env, temp);\n                tcg_temp_free_i32(temp);\n             }\n            break;\n        }\n    }\n    return length;\n}"}
{"idx": 24799, "func": "bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,\n    size_t len)\n{\n    hwaddr mapped_len = 0;\n    struct iovec *ventry;\n    assert(pkt);\n    assert(pkt->max_raw_frags > pkt->raw_frags);\n    if (!len) {\n        return true;\n     }\n    ventry = &pkt->raw[pkt->raw_frags];\n    mapped_len = len;\n    ventry->iov_base = cpu_physical_memory_map(pa, &mapped_len, false);\n    ventry->iov_len = mapped_len;\n    pkt->raw_frags += !!ventry->iov_base;\n    if ((ventry->iov_base == NULL) || (len != mapped_len)) {\n        return false;\n    }\n    return true;\n}"}
{"idx": 24803, "func": "static void quorum_vote(QuorumAIOCB *acb)\n{\n    bool quorum = true;\n    int i, j, ret;\n    QuorumVoteValue hash;\n    BDRVQuorumState *s = acb->common.bs->opaque;\n    QuorumVoteVersion *winner;\n    if (quorum_has_too_much_io_failed(acb)) {\n        return;\n    }\n    for (i = 0; i < s->num_children; i++) {\n        if (!acb->qcrs[i].ret) {\n            break;\n        }\n    }\n    assert(i < s->num_children);\n    for (j = i + 1; j < s->num_children; j++) {\n        if (acb->qcrs[j].ret) {\n            continue;\n        }\n        quorum = quorum_compare(acb, &acb->qcrs[i].qiov, &acb->qcrs[j].qiov);\n        if (!quorum) {\n            break;\n       }\n    }\n    if (quorum) {\n        quorum_copy_qiov(acb->qiov, &acb->qcrs[i].qiov);\n        return;\n    }\n    for (i = 0; i < s->num_children; i++) {\n        if (acb->qcrs[i].ret) {\n            continue;\n        }\n        ret = quorum_compute_hash(acb, i, &hash);\n        if (ret < 0) {\n            acb->vote_ret = ret;\n            goto free_exit;\n        }\n        quorum_count_vote(&acb->votes, &hash, i);\n    }\n    winner = quorum_get_vote_winner(&acb->votes);\n    if (winner->vote_count < s->threshold) {\n        quorum_report_failure(acb);\n        acb->vote_ret = -EIO;\n        goto free_exit;\n    }\n    quorum_copy_qiov(acb->qiov, &acb->qcrs[winner->index].qiov);\n    quorum_report_bad_versions(s, acb, &winner->value);\nfree_exit:\n    quorum_free_vote_list(&acb->votes);\n}"}
{"idx": 24804, "func": "static void stellaris_init(const char *kernel_filename, const char *cpu_model,\n                           stellaris_board_info *board)\n{\n    static const int uart_irq[] = {5, 6, 33, 34};\n    static const int timer_irq[] = {19, 21, 23, 35};\n    static const uint32_t gpio_addr[7] =\n      { 0x40004000, 0x40005000, 0x40006000, 0x40007000,\n        0x40024000, 0x40025000, 0x40026000};\n    static const int gpio_irq[7] = {0, 1, 2, 3, 4, 30, 31};\n    qemu_irq *pic;\n    DeviceState *gpio_dev[7];\n    qemu_irq gpio_in[7][8];\n    qemu_irq gpio_out[7][8];\n    qemu_irq adc;\n    int sram_size;\n    int flash_size;\n    I2CBus *i2c;\n    DeviceState *dev;\n    int i;\n    int j;\n    MemoryRegion *sram = g_new(MemoryRegion, 1);\n    MemoryRegion *flash = g_new(MemoryRegion, 1);\n    MemoryRegion *system_memory = get_system_memory();\n    flash_size = (((board->dc0 & 0xffff) + 1) << 1) * 1024;\n    sram_size = ((board->dc0 >> 18) + 1) * 1024;\n    memory_region_init_ram(flash, NULL, \"stellaris.flash\", flash_size,\n                           &error_abort);\n    vmstate_register_ram_global(flash);\n    memory_region_set_readonly(flash, true);\n    memory_region_add_subregion(system_memory, 0, flash);\n    memory_region_init_ram(sram, NULL, \"stellaris.sram\", sram_size,\n                           &error_abort);\n    vmstate_register_ram_global(sram);\n    memory_region_add_subregion(system_memory, 0x20000000, sram);\n    pic = armv7m_init(system_memory, flash_size, NUM_IRQ_LINES,\n                      kernel_filename, cpu_model);\n    if (board->dc1 & (1 << 16)) {\n        dev = sysbus_create_varargs(TYPE_STELLARIS_ADC, 0x40038000,\n                                    pic[14], pic[15], pic[16], pic[17], NULL);\n        adc = qdev_get_gpio_in(dev, 0);\n    } else {\n        adc = NULL;\n    }\n    for (i = 0; i < 4; i++) {\n        if (board->dc2 & (0x10000 << i)) {\n            dev = sysbus_create_simple(TYPE_STELLARIS_GPTM,\n                                       0x40030000 + i * 0x1000,\n                                       pic[timer_irq[i]]);\n            qdev_connect_gpio_out(dev, 0, adc);\n        }\n    }\n    stellaris_sys_init(0x400fe000, pic[28], board, nd_table[0].macaddr.a);\n    for (i = 0; i < 7; i++) {\n        if (board->dc4 & (1 << i)) {\n            gpio_dev[i] = sysbus_create_simple(\"pl061_luminary\", gpio_addr[i],\n                                               pic[gpio_irq[i]]);\n            for (j = 0; j < 8; j++) {\n                gpio_in[i][j] = qdev_get_gpio_in(gpio_dev[i], j);\n                gpio_out[i][j] = NULL;\n            }\n        }\n    }\n    if (board->dc2 & (1 << 12)) {\n        dev = sysbus_create_simple(TYPE_STELLARIS_I2C, 0x40020000, pic[8]);\n        i2c = (I2CBus *)qdev_get_child_bus(dev, \"i2c\");\n        if (board->peripherals & BP_OLED_I2C) {\n            i2c_create_slave(i2c, \"ssd0303\", 0x3d);\n        }\n    }\n    for (i = 0; i < 4; i++) {\n        if (board->dc2 & (1 << i)) {\n            sysbus_create_simple(\"pl011_luminary\", 0x4000c000 + i * 0x1000,\n                                 pic[uart_irq[i]]);\n        }\n    }\n    if (board->dc2 & (1 << 4)) {\n        dev = sysbus_create_simple(\"pl022\", 0x40008000, pic[7]);\n        if (board->peripherals & BP_OLED_SSI) {\n            void *bus;\n            DeviceState *sddev;\n            DeviceState *ssddev;\n            bus = qdev_get_child_bus(dev, \"ssi\");\n            sddev = ssi_create_slave(bus, \"ssi-sd\");\n            ssddev = ssi_create_slave(bus, \"ssd0323\");\n            gpio_out[GPIO_D][0] = qemu_irq_split(\n                    qdev_get_gpio_in_named(sddev, SSI_GPIO_CS, 0),\n                    qdev_get_gpio_in_named(ssddev, SSI_GPIO_CS, 0));\n            gpio_out[GPIO_C][7] = qdev_get_gpio_in(ssddev, 0);\n            qemu_irq_raise(gpio_out[GPIO_D][0]);\n        }\n    }\n    if (board->dc4 & (1 << 28)) {\n        DeviceState *enet;\n        qemu_check_nic_model(&nd_table[0], \"stellaris\");\n        enet = qdev_create(NULL, \"stellaris_enet\");\n        qdev_set_nic_properties(enet, &nd_table[0]);\n        qdev_init_nofail(enet);\n        sysbus_mmio_map(SYS_BUS_DEVICE(enet), 0, 0x40048000);\n        sysbus_connect_irq(SYS_BUS_DEVICE(enet), 0, pic[42]);\n    }\n    if (board->peripherals & BP_GAMEPAD) {\n        qemu_irq gpad_irq[5];\n        static const int gpad_keycode[5] = { 0xc8, 0xd0, 0xcb, 0xcd, 0x1d };\n        gpad_irq[0] = qemu_irq_invert(gpio_in[GPIO_E][0]);  \n        gpad_irq[1] = qemu_irq_invert(gpio_in[GPIO_E][1]);  \n        gpad_irq[2] = qemu_irq_invert(gpio_in[GPIO_E][2]);  \n        gpad_irq[3] = qemu_irq_invert(gpio_in[GPIO_E][3]);  \n        gpad_irq[4] = qemu_irq_invert(gpio_in[GPIO_F][1]);  \n        stellaris_gamepad_init(5, gpad_irq, gpad_keycode);\n    }\n    for (i = 0; i < 7; i++) {\n        if (board->dc4 & (1 << i)) {\n            for (j = 0; j < 8; j++) {\n                if (gpio_out[i][j]) {\n                    qdev_connect_gpio_out(gpio_dev[i], j, gpio_out[i][j]);\n                }\n            }\n        }\n    }\n}"}
{"idx": 24806, "func": "static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,\n\tlong width, long height,\n\tlong lumStride, long chromStride, long dstStride)\n{\n\tRENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);\n}"}
{"idx": 24809, "func": "static int open_output_file(OptionsContext *o, const char *filename)\n{\n    AVFormatContext *oc;\n    int i, j, err;\n    AVOutputFormat *file_oformat;\n    OutputFile *of;\n    OutputStream *ost;\n    InputStream  *ist;\n    AVDictionary *unused_opts = NULL;\n    AVDictionaryEntry *e = NULL;\n    if (configure_complex_filters() < 0) {\n        av_log(NULL, AV_LOG_FATAL, \"Error configuring filters.\\n\");\n        exit_program(1);\n    }\n    if (o->stop_time != INT64_MAX && o->recording_time != INT64_MAX) {\n        o->stop_time = INT64_MAX;\n        av_log(NULL, AV_LOG_WARNING, \"-t and -to cannot be used together; using -t.\\n\");\n    }\n    if (o->stop_time != INT64_MAX && o->recording_time == INT64_MAX) {\n        int64_t start_time = o->start_time == AV_NOPTS_VALUE ? 0 : o->start_time;\n        if (o->stop_time <= start_time) {\n            av_log(NULL, AV_LOG_WARNING, \"-to value smaller than -ss; ignoring -to.\\n\");\n            o->stop_time = INT64_MAX;\n        } else {\n            o->recording_time = o->stop_time - start_time;\n        }\n    }\n    GROW_ARRAY(output_files, nb_output_files);\n    of = av_mallocz(sizeof(*of));\n    if (!of)\n        exit_program(1);\n    output_files[nb_output_files - 1] = of;\n    of->ost_index      = nb_output_streams;\n    of->recording_time = o->recording_time;\n    of->start_time     = o->start_time;\n    of->limit_filesize = o->limit_filesize;\n    of->shortest       = o->shortest;\n    av_dict_copy(&of->opts, o->g->format_opts, 0);\n    if (!strcmp(filename, \"-\"))\n        filename = \"pipe:\";\n    err = avformat_alloc_output_context2(&oc, NULL, o->format, filename);\n    if (!oc) {\n        print_error(filename, err);\n        exit_program(1);\n    }\n    of->ctx = oc;\n    if (o->recording_time != INT64_MAX)\n        oc->duration = o->recording_time;\n    file_oformat= oc->oformat;\n    oc->interrupt_callback = int_cb;\n    for (i = 0; i < nb_filtergraphs; i++) {\n        FilterGraph *fg = filtergraphs[i];\n        for (j = 0; j < fg->nb_outputs; j++) {\n            OutputFilter *ofilter = fg->outputs[j];\n            if (!ofilter->out_tmp || ofilter->out_tmp->name)\n                continue;\n            switch (avfilter_pad_get_type(ofilter->out_tmp->filter_ctx->output_pads,\n                                          ofilter->out_tmp->pad_idx)) {\n            case AVMEDIA_TYPE_VIDEO:    o->video_disable    = 1; break;\n            case AVMEDIA_TYPE_AUDIO:    o->audio_disable    = 1; break;\n            case AVMEDIA_TYPE_SUBTITLE: o->subtitle_disable = 1; break;\n            }\n            init_output_filter(ofilter, o, oc);\n        }\n    }\n    if (!strcmp(file_oformat->name, \"ffm\") &&\n        av_strstart(filename, \"http:\", NULL)) {\n        int err = parse_option(o, \"metadata\", \"creation_time=now\", options);\n        if (err < 0) {\n            print_error(filename, err);\n            exit_program(1);\n        }\n    }\n    if (!strcmp(file_oformat->name, \"ffm\") && !override_ffserver &&\n        av_strstart(filename, \"http:\", NULL)) {\n        int j;\n        int err = read_ffserver_streams(o, oc, filename);\n        if (err < 0) {\n            print_error(filename, err);\n            exit_program(1);\n        }\n        for(j = nb_output_streams - oc->nb_streams; j < nb_output_streams; j++) {\n            ost = output_streams[j];\n            for (i = 0; i < nb_input_streams; i++) {\n                ist = input_streams[i];\n                if(ist->st->codec->codec_type == ost->st->codec->codec_type){\n                    ost->sync_ist= ist;\n                    ost->source_index= i;\n                    if(ost->st->codec->codec_type == AVMEDIA_TYPE_AUDIO) ost->avfilter = av_strdup(\"anull\");\n                    if(ost->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) ost->avfilter = av_strdup(\"null\");\n                    ist->discard = 0;\n                    ist->st->discard = AVDISCARD_NONE;\n                    break;\n                }\n            }\n            if(!ost->sync_ist){\n                av_log(NULL, AV_LOG_FATAL, \"Missing %s stream which is required by this ffm\\n\", av_get_media_type_string(ost->st->codec->codec_type));\n                exit_program(1);\n            }\n        }\n    } else if (!o->nb_stream_maps) {\n        char *subtitle_codec_name = NULL;\n        if (!o->video_disable && oc->oformat->video_codec != AV_CODEC_ID_NONE) {\n            int area = 0, idx = -1;\n            int qcr = avformat_query_codec(oc->oformat, oc->oformat->video_codec, 0);\n            for (i = 0; i < nb_input_streams; i++) {\n                int new_area;\n                ist = input_streams[i];\n                new_area = ist->st->codec->width * ist->st->codec->height;\n                if((qcr!=MKTAG('A', 'P', 'I', 'C')) && (ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC))\n                    new_area = 1;\n                if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&\n                    new_area > area) {\n                    if((qcr==MKTAG('A', 'P', 'I', 'C')) && !(ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC))\n                        continue;\n                    area = new_area;\n                    idx = i;\n                }\n            }\n            if (idx >= 0)\n                new_video_stream(o, oc, idx);\n        }\n        if (!o->audio_disable && oc->oformat->audio_codec != AV_CODEC_ID_NONE) {\n            int channels = 0, idx = -1;\n            for (i = 0; i < nb_input_streams; i++) {\n                ist = input_streams[i];\n                if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO &&\n                    ist->st->codec->channels > channels) {\n                    channels = ist->st->codec->channels;\n                    idx = i;\n                }\n            }\n            if (idx >= 0)\n                new_audio_stream(o, oc, idx);\n        }\n        MATCH_PER_TYPE_OPT(codec_names, str, subtitle_codec_name, oc, \"s\");\n        if (!o->subtitle_disable && (oc->oformat->subtitle_codec != AV_CODEC_ID_NONE || subtitle_codec_name)) {\n            for (i = 0; i < nb_input_streams; i++)\n                if (input_streams[i]->st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) {\n                    new_subtitle_stream(o, oc, i);\n                    break;\n                }\n        }\n    } else {\n        for (i = 0; i < o->nb_stream_maps; i++) {\n            StreamMap *map = &o->stream_maps[i];\n            if (map->disabled)\n                continue;\n            if (map->linklabel) {\n                FilterGraph *fg;\n                OutputFilter *ofilter = NULL;\n                int j, k;\n                for (j = 0; j < nb_filtergraphs; j++) {\n                    fg = filtergraphs[j];\n                    for (k = 0; k < fg->nb_outputs; k++) {\n                        AVFilterInOut *out = fg->outputs[k]->out_tmp;\n                        if (out && !strcmp(out->name, map->linklabel)) {\n                            ofilter = fg->outputs[k];\n                            goto loop_end;\n                        }\n                    }\n                }\nloop_end:\n                if (!ofilter) {\n                    av_log(NULL, AV_LOG_FATAL, \"Output with label '%s' does not exist \"\n                           \"in any defined filter graph, or was already used elsewhere.\\n\", map->linklabel);\n                    exit_program(1);\n                }\n                init_output_filter(ofilter, o, oc);\n            } else {\n                int src_idx = input_files[map->file_index]->ist_index + map->stream_index;\n                ist = input_streams[input_files[map->file_index]->ist_index + map->stream_index];\n                if(o->subtitle_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE)\n                    continue;\n                if(o->   audio_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO)\n                    continue;\n                if(o->   video_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO)\n                    continue;\n                if(o->    data_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_DATA)\n                    continue;\n                switch (ist->st->codec->codec_type) {\n                case AVMEDIA_TYPE_VIDEO:      ost = new_video_stream     (o, oc, src_idx); break;\n                case AVMEDIA_TYPE_AUDIO:      ost = new_audio_stream     (o, oc, src_idx); break;\n                case AVMEDIA_TYPE_SUBTITLE:   ost = new_subtitle_stream  (o, oc, src_idx); break;\n                case AVMEDIA_TYPE_DATA:       ost = new_data_stream      (o, oc, src_idx); break;\n                case AVMEDIA_TYPE_ATTACHMENT: ost = new_attachment_stream(o, oc, src_idx); break;\n                default:\n                    av_log(NULL, AV_LOG_FATAL, \"Cannot map stream #%d:%d - unsupported type.\\n\",\n                           map->file_index, map->stream_index);\n                    exit_program(1);\n                }\n            }\n        }\n    }\n    for (i = 0; i < o->nb_attachments; i++) {\n        AVIOContext *pb;\n        uint8_t *attachment;\n        const char *p;\n        int64_t len;\n        if ((err = avio_open2(&pb, o->attachments[i], AVIO_FLAG_READ, &int_cb, NULL)) < 0) {\n            av_log(NULL, AV_LOG_FATAL, \"Could not open attachment file %s.\\n\",\n                   o->attachments[i]);\n            exit_program(1);\n        }\n        if ((len = avio_size(pb)) <= 0) {\n            av_log(NULL, AV_LOG_FATAL, \"Could not get size of the attachment %s.\\n\",\n                   o->attachments[i]);\n            exit_program(1);\n        }\n        if (!(attachment = av_malloc(len))) {\n            av_log(NULL, AV_LOG_FATAL, \"Attachment %s too large to fit into memory.\\n\",\n                   o->attachments[i]);\n            exit_program(1);\n        }\n        avio_read(pb, attachment, len);\n        ost = new_attachment_stream(o, oc, -1);\n        ost->stream_copy               = 0;\n        ost->attachment_filename       = o->attachments[i];\n        ost->finished                  = 1;\n        ost->st->codec->extradata      = attachment;\n        ost->st->codec->extradata_size = len;\n        p = strrchr(o->attachments[i], '/');\n        av_dict_set(&ost->st->metadata, \"filename\", (p && *p) ? p + 1 : o->attachments[i], AV_DICT_DONT_OVERWRITE);\n        avio_close(pb);\n    }\n    for (i = nb_output_streams - oc->nb_streams; i < nb_output_streams; i++) {  \n        AVDictionaryEntry *e;\n        ost = output_streams[i];\n        if ((ost->stream_copy || ost->attachment_filename)\n            && (e = av_dict_get(o->g->codec_opts, \"flags\", NULL, AV_DICT_IGNORE_SUFFIX))\n            && (!e->key[5] || check_stream_specifier(oc, ost->st, e->key+6)))\n            if (av_opt_set(ost->st->codec, \"flags\", e->value, 0) < 0)\n                exit_program(1);\n    }\n    unused_opts = strip_specifiers(o->g->codec_opts);\n    for (i = of->ost_index; i < nb_output_streams; i++) {\n        e = NULL;\n        while ((e = av_dict_get(output_streams[i]->opts, \"\", e,\n                                AV_DICT_IGNORE_SUFFIX)))\n            av_dict_set(&unused_opts, e->key, NULL, 0);\n    }\n    e = NULL;\n    while ((e = av_dict_get(unused_opts, \"\", e, AV_DICT_IGNORE_SUFFIX))) {\n        const AVClass *class = avcodec_get_class();\n        const AVOption *option = av_opt_find(&class, e->key, NULL, 0,\n                                             AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ);\n        if (!option)\n            continue;\n        if (!(option->flags & AV_OPT_FLAG_ENCODING_PARAM)) {\n            av_log(NULL, AV_LOG_ERROR, \"Codec AVOption %s (%s) specified for \"\n                   \"output file #%d (%s) is not an encoding option.\\n\", e->key,\n                   option->help ? option->help : \"\", nb_output_files - 1,\n                   filename);\n            exit_program(1);\n        }\n        if (!strcmp(e->key, \"gop_timecode\"))\n            continue;\n        av_log(NULL, AV_LOG_WARNING, \"Codec AVOption %s (%s) specified for \"\n               \"output file #%d (%s) has not been used for any stream. The most \"\n               \"likely reason is either wrong type (e.g. a video option with \"\n               \"no video streams) or that it is a private option of some encoder \"\n               \"which was not actually used for any stream.\\n\", e->key,\n               option->help ? option->help : \"\", nb_output_files - 1, filename);\n    }\n    av_dict_free(&unused_opts);\n    if (oc->oformat->flags & AVFMT_NEEDNUMBER) {\n        if (!av_filename_number_test(oc->filename)) {\n            print_error(oc->filename, AVERROR(EINVAL));\n            exit_program(1);\n        }\n    }\n    if (!(oc->oformat->flags & AVFMT_NOFILE)) {\n        assert_file_overwrite(filename);\n        if ((err = avio_open2(&oc->pb, filename, AVIO_FLAG_WRITE,\n                              &oc->interrupt_callback,\n                              &of->opts)) < 0) {\n            print_error(filename, err);\n            exit_program(1);\n        }\n    } else if (strcmp(oc->oformat->name, \"image2\")==0 && !av_filename_number_test(filename))\n        assert_file_overwrite(filename);\n    if (o->mux_preload) {\n        uint8_t buf[64];\n        snprintf(buf, sizeof(buf), \"%d\", (int)(o->mux_preload*AV_TIME_BASE));\n        av_dict_set(&of->opts, \"preload\", buf, 0);\n    }\n    oc->max_delay = (int)(o->mux_max_delay * AV_TIME_BASE);\n    for (i = 0; i < o->nb_metadata_map; i++) {\n        char *p;\n        int in_file_index = strtol(o->metadata_map[i].u.str, &p, 0);\n        if (in_file_index >= nb_input_files) {\n            av_log(NULL, AV_LOG_FATAL, \"Invalid input file index %d while processing metadata maps\\n\", in_file_index);\n            exit_program(1);\n        }\n        copy_metadata(o->metadata_map[i].specifier, *p ? p + 1 : p, oc,\n                      in_file_index >= 0 ?\n                      input_files[in_file_index]->ctx : NULL, o);\n    }\n    if (o->chapters_input_file >= nb_input_files) {\n        if (o->chapters_input_file == INT_MAX) {\n            o->chapters_input_file = -1;\n            for (i = 0; i < nb_input_files; i++)\n                if (input_files[i]->ctx->nb_chapters) {\n                    o->chapters_input_file = i;\n                    break;\n                }\n        } else {\n            av_log(NULL, AV_LOG_FATAL, \"Invalid input file index %d in chapter mapping.\\n\",\n                   o->chapters_input_file);\n            exit_program(1);\n        }\n    }\n    if (o->chapters_input_file >= 0)\n        copy_chapters(input_files[o->chapters_input_file], of,\n                      !o->metadata_chapters_manual);\n    if (!o->metadata_global_manual && nb_input_files){\n        av_dict_copy(&oc->metadata, input_files[0]->ctx->metadata,\n                     AV_DICT_DONT_OVERWRITE);\n        if(o->recording_time != INT64_MAX)\n            av_dict_set(&oc->metadata, \"duration\", NULL, 0);\n        av_dict_set(&oc->metadata, \"creation_time\", NULL, 0);\n    }\n    if (!o->metadata_streams_manual)\n        for (i = of->ost_index; i < nb_output_streams; i++) {\n            InputStream *ist;\n            if (output_streams[i]->source_index < 0)          \n                continue;\n            ist = input_streams[output_streams[i]->source_index];\n            av_dict_copy(&output_streams[i]->st->metadata, ist->st->metadata, AV_DICT_DONT_OVERWRITE);\n        }\n    for (i = 0; i < o->nb_metadata; i++) {\n        AVDictionary **m;\n        char type, *val;\n        const char *stream_spec;\n        int index = 0, j, ret = 0;\n        val = strchr(o->metadata[i].u.str, '=');\n        if (!val) {\n            av_log(NULL, AV_LOG_FATAL, \"No '=' character in metadata string %s.\\n\",\n                   o->metadata[i].u.str);\n            exit_program(1);\n        }\n        *val++ = 0;\n        parse_meta_type(o->metadata[i].specifier, &type, &index, &stream_spec);\n        if (type == 's') {\n            for (j = 0; j < oc->nb_streams; j++) {\n                if ((ret = check_stream_specifier(oc, oc->streams[j], stream_spec)) > 0) {\n                    av_dict_set(&oc->streams[j]->metadata, o->metadata[i].u.str, *val ? val : NULL, 0);\n                } else if (ret < 0)\n                    exit_program(1);\n            }\n        }\n        else {\n            switch (type) {\n            case 'g':\n                m = &oc->metadata;\n                break;\n            case 'c':\n                if (index < 0 || index >= oc->nb_chapters) {\n                    av_log(NULL, AV_LOG_FATAL, \"Invalid chapter index %d in metadata specifier.\\n\", index);\n                    exit_program(1);\n                }\n                m = &oc->chapters[index]->metadata;\n                break;\n            default:\n                av_log(NULL, AV_LOG_FATAL, \"Invalid metadata specifier %s.\\n\", o->metadata[i].specifier);\n                exit_program(1);\n            }\n            av_dict_set(m, o->metadata[i].u.str, *val ? val : NULL, 0);\n        }\n    }\n    return 0;\n}"}
{"idx": 24811, "func": "static int add_candidate_ref(HEVCContext *s, RefPicList *list,\n                             int poc, int ref_flag)\n{\n    HEVCFrame *ref = find_ref_idx(s, poc);\n    if (ref == s->ref)\n        return AVERROR_INVALIDDATA;\n    if (!ref) {\n        ref = generate_missing_ref(s, poc);\n        if (!ref)\n            return AVERROR(ENOMEM);\n    }\n    list->list[list->nb_refs] = ref->poc;\n    list->ref[list->nb_refs]  = ref;\n    list->nb_refs++;\n    mark_ref(ref, ref_flag);\n    return 0;\n}"}
{"idx": 24812, "func": "static inline void t_gen_mov_preg_TN(DisasContext *dc, int r, TCGv tn)\n{\n    if (r < 0 || r > 15) {\n        fprintf(stderr, \"wrong register write $p%d\\n\", r);\n    }\n    if (r == PR_BZ || r == PR_WZ || r == PR_DZ) {\n        return;\n    } else if (r == PR_SRS) {\n        tcg_gen_andi_tl(cpu_PR[r], tn, 3);\n    } else {\n        if (r == PR_PID) {\n            gen_helper_tlb_flush_pid(cpu_env, tn);\n        }\n        if (dc->tb_flags & S_FLAG && r == PR_SPC) {\n            gen_helper_spc_write(cpu_env, tn);\n        } else if (r == PR_CCS) {\n            dc->cpustate_changed = 1;\n        }\n        tcg_gen_mov_tl(cpu_PR[r], tn);\n    }\n}"}
{"idx": 24815, "func": "static int net_vhost_user_init(NetClientState *peer, const char *device,\n                               const char *name, CharDriverState *chr,\n                               int queues)\n{\n    NetClientState *nc;\n    VhostUserState *s;\n    int i;\n    for (i = 0; i < queues; i++) {\n        nc = qemu_new_net_client(&net_vhost_user_info, peer, device, name);\n        snprintf(nc->info_str, sizeof(nc->info_str), \"vhost-user%d to %s\",\n                 i, chr->label);\n        nc->queue_index = i;\n        s = DO_UPCAST(VhostUserState, nc, nc);\n        s->chr = chr;\n    }\n    qemu_chr_add_handlers(chr, NULL, NULL, net_vhost_user_event, (void*)name);\n    return 0;\n}"}
{"idx": 24826, "func": "int gen_new_label(void)\n{\n    TCGContext *s = &tcg_ctx;\n    int idx;\n    TCGLabel *l;\n    if (s->nb_labels >= TCG_MAX_LABELS)\n        tcg_abort();\n    idx = s->nb_labels++;\n    l = &s->labels[idx];\n    l->has_value = 0;\n    l->u.first_reloc = NULL;\n    return idx;\n}"}
{"idx": 24828, "func": "void tlb_reset_dirty(CPUState *cpu, ram_addr_t start1, ram_addr_t length)\n{\n    CPUArchState *env;\n    int mmu_idx;\n    assert_cpu_is_self(cpu);\n    env = cpu->env_ptr;\n    for (mmu_idx = 0; mmu_idx < NB_MMU_MODES; mmu_idx++) {\n        unsigned int i;\n        for (i = 0; i < CPU_TLB_SIZE; i++) {\n            tlb_reset_dirty_range(&env->tlb_table[mmu_idx][i],\n                                  start1, length);\n        }\n        for (i = 0; i < CPU_VTLB_SIZE; i++) {\n            tlb_reset_dirty_range(&env->tlb_v_table[mmu_idx][i],\n                                  start1, length);\n        }\n    }\n}"}
{"idx": 24833, "func": "static inline void gen_intermediate_code_internal(OpenRISCCPU *cpu,\n                                                  TranslationBlock *tb,\n                                                  int search_pc)\n{\n    CPUState *cs = CPU(cpu);\n    struct DisasContext ctx, *dc = &ctx;\n    uint16_t *gen_opc_end;\n    uint32_t pc_start;\n    int j, k;\n    uint32_t next_page_start;\n    int num_insns;\n    int max_insns;\n    pc_start = tb->pc;\n    dc->tb = tb;\n    gen_opc_end = tcg_ctx.gen_opc_buf + OPC_MAX_SIZE;\n    dc->is_jmp = DISAS_NEXT;\n    dc->ppc = pc_start;\n    dc->pc = pc_start;\n    dc->flags = cpu->env.cpucfgr;\n    dc->mem_idx = cpu_mmu_index(&cpu->env);\n    dc->synced_flags = dc->tb_flags = tb->flags;\n    dc->delayed_branch = !!(dc->tb_flags & D_FLAG);\n    dc->singlestep_enabled = cs->singlestep_enabled;\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n        qemu_log(\"-----------------------------------------\\n\");\n        log_cpu_state(CPU(cpu), 0);\n    }\n    next_page_start = (pc_start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE;\n    k = -1;\n    num_insns = 0;\n    max_insns = tb->cflags & CF_COUNT_MASK;\n    if (max_insns == 0) {\n        max_insns = CF_COUNT_MASK;\n    }\n    gen_tb_start();\n    do {\n        check_breakpoint(cpu, dc);\n        if (search_pc) {\n            j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n            if (k < j) {\n                k++;\n                while (k < j) {\n                    tcg_ctx.gen_opc_instr_start[k++] = 0;\n                }\n            }\n            tcg_ctx.gen_opc_pc[k] = dc->pc;\n            tcg_ctx.gen_opc_instr_start[k] = 1;\n            tcg_ctx.gen_opc_icount[k] = num_insns;\n        }\n        if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) {\n            tcg_gen_debug_insn_start(dc->pc);\n        }\n        if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO)) {\n            gen_io_start();\n        }\n        dc->ppc = dc->pc - 4;\n        dc->npc = dc->pc + 4;\n        tcg_gen_movi_tl(cpu_ppc, dc->ppc);\n        tcg_gen_movi_tl(cpu_npc, dc->npc);\n        disas_openrisc_insn(dc, cpu);\n        dc->pc = dc->npc;\n        num_insns++;\n        if (dc->delayed_branch) {\n            dc->delayed_branch--;\n            if (!dc->delayed_branch) {\n                dc->tb_flags &= ~D_FLAG;\n                gen_sync_flags(dc);\n                tcg_gen_mov_tl(cpu_pc, jmp_pc);\n                tcg_gen_mov_tl(cpu_npc, jmp_pc);\n                tcg_gen_movi_tl(jmp_pc, 0);\n                tcg_gen_exit_tb(0);\n                dc->is_jmp = DISAS_JUMP;\n                break;\n            }\n        }\n    } while (!dc->is_jmp\n             && tcg_ctx.gen_opc_ptr < gen_opc_end\n             && !cs->singlestep_enabled\n             && !singlestep\n             && (dc->pc < next_page_start)\n             && num_insns < max_insns);\n    if (tb->cflags & CF_LAST_IO) {\n        gen_io_end();\n    }\n    if (dc->is_jmp == DISAS_NEXT) {\n        dc->is_jmp = DISAS_UPDATE;\n        tcg_gen_movi_tl(cpu_pc, dc->pc);\n    }\n    if (unlikely(cs->singlestep_enabled)) {\n        if (dc->is_jmp == DISAS_NEXT) {\n            tcg_gen_movi_tl(cpu_pc, dc->pc);\n        }\n        gen_exception(dc, EXCP_DEBUG);\n    } else {\n        switch (dc->is_jmp) {\n        case DISAS_NEXT:\n            gen_goto_tb(dc, 0, dc->pc);\n            break;\n        default:\n        case DISAS_JUMP:\n            break;\n        case DISAS_UPDATE:\n            tcg_gen_exit_tb(0);\n            break;\n        case DISAS_TB_JUMP:\n            break;\n        }\n    }\n    gen_tb_end(tb, num_insns);\n    *tcg_ctx.gen_opc_ptr = INDEX_op_end;\n    if (search_pc) {\n        j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n        k++;\n        while (k <= j) {\n            tcg_ctx.gen_opc_instr_start[k++] = 0;\n        }\n    } else {\n        tb->size = dc->pc - pc_start;\n        tb->icount = num_insns;\n    }\n#ifdef DEBUG_DISAS\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n        qemu_log(\"\\n\");\n        log_target_disas(&cpu->env, pc_start, dc->pc - pc_start, 0);\n        qemu_log(\"\\nisize=%d osize=%td\\n\",\n            dc->pc - pc_start, tcg_ctx.gen_opc_ptr -\n            tcg_ctx.gen_opc_buf);\n    }\n#endif\n}"}
{"idx": 24836, "func": "static int get_coc(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c,\n                   uint8_t *properties)\n{\n    int compno;\n    if (s->buf_end - s->buf < 2)\n        return AVERROR(EINVAL);\n    compno = bytestream_get_byte(&s->buf);\n    c      += compno;\n    c->csty = bytestream_get_byte(&s->buf);\n    get_cox(s, c);\n    properties[compno] |= HAD_COC;\n    return 0;\n}"}
{"idx": 24857, "func": "QEMUBH *aio_bh_new(AioContext *ctx, QEMUBHFunc *cb, void *opaque)\n{\n    QEMUBH *bh;\n    bh = g_malloc0(sizeof(QEMUBH));\n    bh->ctx = ctx;\n    bh->cb = cb;\n    bh->opaque = opaque;\n    qemu_mutex_lock(&ctx->bh_lock);\n    bh->next = ctx->first_bh;\n    smp_wmb();\n    ctx->first_bh = bh;\n    qemu_mutex_unlock(&ctx->bh_lock);\n    return bh;\n}"}
{"idx": 24859, "func": "static void paint_mouse_pointer(AVFormatContext *s1, struct gdigrab *gdigrab)\n{\n    CURSORINFO ci = {0};\n#define CURSOR_ERROR(str)                 \\\n    if (!gdigrab->cursor_error_printed) {       \\\n        WIN32_API_ERROR(str);             \\\n        gdigrab->cursor_error_printed = 1;      \\\n    }\n    ci.cbSize = sizeof(ci);\n    if (GetCursorInfo(&ci)) {\n        HCURSOR icon = CopyCursor(ci.hCursor);\n        ICONINFO info;\n        POINT pos;\n        RECT clip_rect = gdigrab->clip_rect;\n        HWND hwnd = gdigrab->hwnd;\n        info.hbmMask = NULL;\n        info.hbmColor = NULL;\n        if (ci.flags != CURSOR_SHOWING)\n            return;\n        if (!icon) {\n            icon = CopyCursor(LoadCursor(NULL, IDC_ARROW));\n        }\n        if (!GetIconInfo(icon, &info)) {\n            CURSOR_ERROR(\"Could not get icon info\");\n            goto icon_error;\n        }\n        pos.x = ci.ptScreenPos.x - clip_rect.left - info.xHotspot;\n        pos.y = ci.ptScreenPos.y - clip_rect.top - info.yHotspot;\n        if (hwnd) {\n            RECT rect;\n            if (GetWindowRect(hwnd, &rect)) {\n                pos.x -= rect.left;\n                pos.y -= rect.top;\n            } else {\n                CURSOR_ERROR(\"Couldn't get window rectangle\");\n                goto icon_error;\n            }\n        }\n        av_log(s1, AV_LOG_DEBUG, \"Cursor pos (%li,%li) -> (%li,%li)\\n\",\n                ci.ptScreenPos.x, ci.ptScreenPos.y, pos.x, pos.y);\n        if (pos.x >= 0 && pos.x <= clip_rect.right - clip_rect.left &&\n                pos.y >= 0 && pos.y <= clip_rect.bottom - clip_rect.top) {\n            if (!DrawIcon(gdigrab->dest_hdc, pos.x, pos.y, icon))\n                CURSOR_ERROR(\"Couldn't draw icon\");\n        }\nicon_error:\n        if (icon)\n            DestroyCursor(icon);\n    } else {\n        CURSOR_ERROR(\"Couldn't get cursor info\");\n    }\n}"}
{"idx": 24862, "func": "static void hmp_migrate_status_cb(void *opaque)\n{\n    MigrationStatus *status = opaque;\n    MigrationInfo *info;\n    info = qmp_query_migrate(NULL);\n    if (!info->has_status || strcmp(info->status, \"active\") == 0) {\n        if (info->has_disk) {\n            int progress;\n            if (info->disk->remaining) {\n                progress = info->disk->transferred * 100 / info->disk->total;\n            } else {\n                progress = 100;\n            }\n            monitor_printf(status->mon, \"Completed %d %%\\r\", progress);\n            monitor_flush(status->mon);\n        }\n        timer_mod(status->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 1000);\n    } else {\n        if (status->is_block_migration) {\n            monitor_printf(status->mon, \"\\n\");\n        }\n        monitor_resume(status->mon);\n        timer_del(status->timer);\n        g_free(status);\n    }\n    qapi_free_MigrationInfo(info);\n}"}
{"idx": 24863, "func": "int kvm_arch_on_sigbus(int code, void *addr)\n{\n#ifdef KVM_CAP_MCE\n    if ((first_cpu->mcg_cap & MCG_SER_P) && addr && code == BUS_MCEERR_AO) {\n        void *vaddr;\n        ram_addr_t ram_addr;\n        target_phys_addr_t paddr;\n        vaddr = addr;\n        if (qemu_ram_addr_from_host(vaddr, &ram_addr) ||\n            !kvm_physical_memory_addr_from_ram(first_cpu->kvm_state, ram_addr,\n                                               &paddr)) {\n            fprintf(stderr, \"Hardware memory error for memory used by \"\n                    \"QEMU itself instead of guest system!: %p\\n\", addr);\n            return 0;\n        }\n        kvm_mce_inj_srao_memscrub2(first_cpu, paddr);\n    } else\n#endif  \n    {\n        if (code == BUS_MCEERR_AO) {\n            return 0;\n        } else if (code == BUS_MCEERR_AR) {\n            hardware_memory_error();\n        } else {\n            return 1;\n        }\n    }\n    return 0;\n}"}
{"idx": 24866, "func": "static ModuleTypeList *find_type(module_init_type type)\n{\n    ModuleTypeList *l;\n    init_types();\n    l = &init_type_list[type];\n    return l;\n}"}
{"idx": 24874, "func": "static int mkv_write_header(AVFormatContext *s)\n{\n    MatroskaMuxContext *mkv = s->priv_data;\n    AVIOContext *pb = s->pb;\n    ebml_master ebml_header;\n    AVDictionaryEntry *tag;\n    int ret, i, version = 2;\n    int64_t creation_time;\n    if (!strcmp(s->oformat->name, \"webm\"))\n        mkv->mode = MODE_WEBM;\n    else\n        mkv->mode = MODE_MATROSKAv2;\n    if (mkv->mode != MODE_WEBM ||\n        av_dict_get(s->metadata, \"stereo_mode\", NULL, 0) ||\n        av_dict_get(s->metadata, \"alpha_mode\", NULL, 0))\n        version = 4;\n    if (s->nb_streams > MAX_TRACKS) {\n        av_log(s, AV_LOG_ERROR,\n               \"At most %d streams are supported for muxing in Matroska\\n\",\n               MAX_TRACKS);\n        return AVERROR(EINVAL);\n    }\n    for (i = 0; i < s->nb_streams; i++) {\n        if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_ATRAC3 ||\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_COOK ||\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RA_288 ||\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_SIPR ||\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV10 ||\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV20) {\n            av_log(s, AV_LOG_ERROR,\n                   \"The Matroska muxer does not yet support muxing %s\\n\",\n                   avcodec_get_name(s->streams[i]->codecpar->codec_id));\n            return AVERROR_PATCHWELCOME;\n        }\n        if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_OPUS ||\n            av_dict_get(s->streams[i]->metadata, \"stereo_mode\", NULL, 0) ||\n            av_dict_get(s->streams[i]->metadata, \"alpha_mode\", NULL, 0))\n            version = 4;\n    }\n    mkv->tracks = av_mallocz_array(s->nb_streams, sizeof(*mkv->tracks));\n    if (!mkv->tracks) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n    ebml_header = start_ebml_master(pb, EBML_ID_HEADER, 0);\n    put_ebml_uint   (pb, EBML_ID_EBMLVERSION        ,           1);\n    put_ebml_uint   (pb, EBML_ID_EBMLREADVERSION    ,           1);\n    put_ebml_uint   (pb, EBML_ID_EBMLMAXIDLENGTH    ,           4);\n    put_ebml_uint   (pb, EBML_ID_EBMLMAXSIZELENGTH  ,           8);\n    put_ebml_string (pb, EBML_ID_DOCTYPE            , s->oformat->name);\n    put_ebml_uint   (pb, EBML_ID_DOCTYPEVERSION     ,     version);\n    put_ebml_uint   (pb, EBML_ID_DOCTYPEREADVERSION ,           2);\n    end_ebml_master(pb, ebml_header);\n    mkv->segment = start_ebml_master(pb, MATROSKA_ID_SEGMENT, 0);\n    mkv->segment_offset = avio_tell(pb);\n    mkv->main_seekhead    = mkv_start_seekhead(pb, mkv->segment_offset, 10);\n    if (!mkv->main_seekhead) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n    ret = mkv_add_seekhead_entry(mkv->main_seekhead, MATROSKA_ID_INFO, avio_tell(pb));\n    if (ret < 0) goto fail;\n    ret = start_ebml_master_crc32(pb, &mkv->info_bc, mkv, &mkv->info, MATROSKA_ID_INFO, 0);\n    if (ret < 0)\n        return ret;\n    pb = mkv->info_bc;\n    put_ebml_uint(pb, MATROSKA_ID_TIMECODESCALE, 1000000);\n    if ((tag = av_dict_get(s->metadata, \"title\", NULL, 0)))\n        put_ebml_string(pb, MATROSKA_ID_TITLE, tag->value);\n    if (!(s->flags & AVFMT_FLAG_BITEXACT)) {\n        put_ebml_string(pb, MATROSKA_ID_MUXINGAPP, LIBAVFORMAT_IDENT);\n        if ((tag = av_dict_get(s->metadata, \"encoding_tool\", NULL, 0)))\n            put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, tag->value);\n        else\n            put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, LIBAVFORMAT_IDENT);\n        if (mkv->mode != MODE_WEBM) {\n            uint32_t segment_uid[4];\n            AVLFG lfg;\n            av_lfg_init(&lfg, av_get_random_seed());\n            for (i = 0; i < 4; i++)\n                segment_uid[i] = av_lfg_get(&lfg);\n            put_ebml_binary(pb, MATROSKA_ID_SEGMENTUID, segment_uid, 16);\n        }\n    } else {\n        const char *ident = \"Lavf\";\n        put_ebml_string(pb, MATROSKA_ID_MUXINGAPP , ident);\n        put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, ident);\n    }\n    if (ff_parse_creation_time_metadata(s, &creation_time, 0) > 0) {\n        int64_t date_utc = (creation_time - 978307200000000LL) * 1000;\n        uint8_t date_utc_buf[8];\n        AV_WB64(date_utc_buf, date_utc);\n        put_ebml_binary(pb, MATROSKA_ID_DATEUTC, date_utc_buf, 8);\n    }\n    mkv->duration = 0;\n    mkv->duration_offset = avio_tell(pb);\n    if (!mkv->is_live) {\n        int64_t metadata_duration = get_metadata_duration(s);\n        if (s->duration > 0) {\n            int64_t scaledDuration = av_rescale(s->duration, 1000, AV_TIME_BASE);\n            put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration);\n            av_log(s, AV_LOG_DEBUG, \"Write early duration from recording time = %\" PRIu64 \"\\n\", scaledDuration);\n        } else if (metadata_duration > 0) {\n            int64_t scaledDuration = av_rescale(metadata_duration, 1000, AV_TIME_BASE);\n            put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration);\n            av_log(s, AV_LOG_DEBUG, \"Write early duration from metadata = %\" PRIu64 \"\\n\", scaledDuration);\n        } else {\n            put_ebml_void(pb, 11);               \n        }\n    }\n    if ((s->pb->seekable & AVIO_SEEKABLE_NORMAL) && !mkv->is_live)\n        end_ebml_master_crc32_preliminary(s->pb, &mkv->info_bc, mkv, mkv->info);\n    else\n        end_ebml_master_crc32(s->pb, &mkv->info_bc, mkv, mkv->info);\n    pb = s->pb;\n    mkv->stream_durations = av_mallocz(s->nb_streams * sizeof(int64_t));\n    mkv->stream_duration_offsets = av_mallocz(s->nb_streams * sizeof(int64_t));\n    ret = mkv_write_tracks(s);\n    if (ret < 0)\n        goto fail;\n    for (i = 0; i < s->nb_chapters; i++)\n        mkv->chapter_id_offset = FFMAX(mkv->chapter_id_offset, 1LL - s->chapters[i]->id);\n    ret = mkv_write_chapters(s);\n    if (ret < 0)\n        goto fail;\n    if (mkv->mode != MODE_WEBM) {\n        ret = mkv_write_attachments(s);\n        if (ret < 0)\n            goto fail;\n    }\n    ret = mkv_write_tags(s);\n    if (ret < 0)\n        goto fail;\n    if (!(s->pb->seekable & AVIO_SEEKABLE_NORMAL) && !mkv->is_live)\n        mkv_write_seekhead(pb, mkv);\n    mkv->cues = mkv_start_cues(mkv->segment_offset);\n    if (!mkv->cues) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n    if ((pb->seekable & AVIO_SEEKABLE_NORMAL) && mkv->reserve_cues_space) {\n        mkv->cues_pos = avio_tell(pb);\n        put_ebml_void(pb, mkv->reserve_cues_space);\n    }\n    av_init_packet(&mkv->cur_audio_pkt);\n    mkv->cur_audio_pkt.size = 0;\n    mkv->cluster_pos = -1;\n    avio_flush(pb);\n    if (pb->seekable & AVIO_SEEKABLE_NORMAL) {\n        if (mkv->cluster_time_limit < 0)\n            mkv->cluster_time_limit = 5000;\n        if (mkv->cluster_size_limit < 0)\n            mkv->cluster_size_limit = 5 * 1024 * 1024;\n    } else {\n        if (mkv->cluster_time_limit < 0)\n            mkv->cluster_time_limit = 1000;\n        if (mkv->cluster_size_limit < 0)\n            mkv->cluster_size_limit = 32 * 1024;\n    }\n    return 0;\nfail:\n    mkv_free(mkv);\n    return ret;\n}"}
{"idx": 24878, "func": "static int decode_hq_slice(AVCodecContext *avctx, void *arg)\n{\n    int i, quant, level, orientation, quant_idx;\n    uint8_t quants[MAX_DWT_LEVELS][4];\n    DiracContext *s = avctx->priv_data;\n    DiracSlice *slice = arg;\n    GetBitContext *gb = &slice->gb;\n    skip_bits_long(gb, 8*s->highquality.prefix_bytes);\n    quant_idx = get_bits(gb, 8);\n    for (level = 0; level < s->wavelet_depth; level++) {\n        for (orientation = !!level; orientation < 4; orientation++) {\n            quant = FFMAX(quant_idx - s->lowdelay.quant[level][orientation], 0);\n            quants[level][orientation] = quant;\n        }\n    }\n    for (i = 0; i < 3; i++) {\n        int64_t length = s->highquality.size_scaler * get_bits(gb, 8);\n        int64_t bits_left = 8 * length;\n        int64_t bits_end = get_bits_count(gb) + bits_left;\n        if (bits_end >= INT_MAX) {\n            av_log(s->avctx, AV_LOG_ERROR, \"end too far away\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        for (level = 0; level < s->wavelet_depth; level++) {\n            for (orientation = !!level; orientation < 4; orientation++) {\n                decode_subband(s, gb, quants[level][orientation], slice->slice_x, slice->slice_y, bits_end,\n                               &s->plane[i].band[level][orientation], NULL);\n            }\n        }\n        skip_bits_long(gb, bits_end - get_bits_count(gb));\n    }\n    return 0;\n}"}
{"idx": 24883, "func": "static void gen_check_sr(DisasContext *dc, uint32_t sr, unsigned access)\n{\n    if (!xtensa_option_bits_enabled(dc->config, sregnames[sr].opt_bits)) {\n        if (sregnames[sr].name) {\n            qemu_log(\"SR %s is not configured\\n\", sregnames[sr].name);\n        } else {\n            qemu_log(\"SR %d is not implemented\\n\", sr);\n        }\n        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n    } else if (!(sregnames[sr].access & access)) {\n        static const char * const access_text[] = {\n            [SR_R] = \"rsr\",\n            [SR_W] = \"wsr\",\n            [SR_X] = \"xsr\",\n        };\n        assert(access < ARRAY_SIZE(access_text) && access_text[access]);\n        qemu_log(\"SR %s is not available for %s\\n\", sregnames[sr].name,\n                access_text[access]);\n        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n    }\n}"}
